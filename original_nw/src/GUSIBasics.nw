%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Project	:	GUSI				-	Grand Unified Socket Interface
% File		:	GUSIBasics.nw		-	Common routines for GUSI
% Author	:	Matthias Neeracher
% Language	:	C++
% 
% $Log: GUSIBasics.nw,v $
% Revision 1.21  2002/01/07 05:56:20  neeri
% Compatibility fixes for CodeWarrior Pro 7
%
% Revision 1.20  2001/01/17 08:32:30  neeri
% Atomic locks turned out not to be necessary after all
%
% Revision 1.19  2001/01/17 08:31:10  neeri
% Added PPC error codes, tweaked nullEvent handling, added atomic locks
%
% Revision 1.18  2000/10/16 04:34:22  neeri
% Releasing 2.1.2
%
% Revision 1.17  2000/06/12 04:20:58  neeri
% Introduce GUSI_*printf
%
% Revision 1.16  2000/05/23 06:51:55  neeri
% Reorganize errors to improve formatting
%
% Revision 1.15  2000/03/15 07:22:05  neeri
% Enforce alignment choices
%
% Revision 1.14  1999/08/26 05:44:58  neeri
% Fixes for literate edition of source code
%
% Revision 1.13  1999/08/02 07:02:42  neeri
% Support for asynchronous errors and other socket options
%
% Revision 1.12  1999/06/28 05:56:01  neeri
% Get rid of STL includes in header
%
% Revision 1.11  1999/06/08 04:31:29  neeri
% Getting ready for 2.0b2
%
% Revision 1.10  1999/05/30 03:09:28  neeri
% Added support for MPW compilers
%
% Revision 1.9  1999/04/10 04:45:05  neeri
% Handle MacTCP errors correctly
%
% Revision 1.8  1999/03/17 09:05:04  neeri
% Added GUSITimer, expanded docs
%
% Revision 1.7  1998/10/25 11:57:33  neeri
% Ready to release 2.0a3
%
% Revision 1.6  1998/10/11 16:45:09  neeri
% Ready to release 2.0a2
%
% Revision 1.5  1998/01/25 20:53:50  neeri
% Engine implemented, except for signals & scheduling
%
% Revision 1.4  1996/12/22 19:57:54  neeri
% TCP streams work
%
% Revision 1.3  1996/11/24  12:52:04  neeri
% Added GUSIPipeSockets
%
% Revision 1.2  1996/11/18  00:53:46  neeri
% TestTimers (basic threading/timer test) works
%
% Revision 1.1.1.1  1996/11/03  02:43:32  neeri
% Imported into CVS
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Common routines for GUSI}

This section defines various services used by all parts of GUSI:

\begin{itemize}
\item Various hooks to customize GUSI.
\item The propagation of {\bf errors} to the [[errno]] and [[h_errno]] 
global variables.
\item Waiting for completion of asynchronous calls.
\item Event handling.
\item Compiler features.
\end{itemize}

To protect our name space further, we maintain a strict C interface unless 
[[GUSI_SOURCE]] is defined, and may avoid defining some stuff unless 
[[GUSI_INTERNAL]] is defined. The following header is therefore included 
first by all GUSI source files.
<<GUSIInternal.h>>=
#ifndef _GUSIInternal_
#define _GUSIInternal_

#include <ConditionalMacros.h>

#define GUSI_SOURCE
#define GUSI_INTERNAL

#if !TARGET_RT_MAC_CFM
#pragma segment GUSI
#endif

#endif /* _GUSIInternal_ */
@

<<GUSIBasics.h>>=
#ifndef _GUSIBasics_
#define _GUSIBasics_

#ifdef GUSI_SOURCE

#include <errno.h>
#include <sys/cdefs.h>
#include <stdarg.h>

#include <ConditionalMacros.h>

<<Definition of compiler features>>
<<Definition of hook handling>>
<<Definition of error handling>>
<<Definition of event handling>>
<<Definition of string formatting>>

#endif /* GUSI_SOURCE */

#endif /* _GUSIBasics_ */
@

<<GUSIBasics.cp>>=
#define GUSI_MESSAGE_LEVEL 5

#include "GUSIInternal.h"
#include "GUSIBasics.h"
#include "GUSIDiag.h"

#include <errno.h>
#include <netdb.h>
#include <stdio.h>

#include <MacTypes.h>
#include <Events.h>
#include <Files.h>
#include <OSUtils.h>
#include <EPPC.h>
#include <LowMem.h>
#include <AppleEvents.h>
#include <Quickdraw.h>
#include <MacTCP.h>
#include <OpenTransport.h>

<<Implementation of hook handling>>
<<Implementation of error handling>>
<<Implementation of event handling>>
<<Implementation of string formatting>>
@

\section{Definition of compiler features}

If possible, we use unnamed namespaces to wrap internal code.
<<Definition of compiler features>>=
#ifdef __MWERKS__
#define GUSI_COMPILER_HAS_NAMESPACE
#endif

#ifdef GUSI_COMPILER_HAS_NAMESPACE
#define GUSI_USING_STD_NAMESPACE using namespace std; using namespace std::rel_ops;
#else
#define GUSI_USING_STD_NAMESPACE
#endif

@ %def GUSI_COMPILER_HAS_NAMESPACE

Asynchronous MacOS calls need completion procedures which in classic 68K code 
often take parameters in address registers. The way to handle this differs
a bit between compilers. Note that the [[pascal]] keyword is ignored when
generating CFM code.
<<Definition of compiler features>>=
#if GENERATINGCFM
#define GUSI_COMPLETION_PROC_A0(proc, type) \
	pascal void (*proc##Entry)(type * param) 	= 	proc;
#define GUSI_COMPLETION_PROC_A1(proc, type) \
	pascal void (*proc##Entry)(type * param) 	= 	proc;
#elif defined(__MWERKS__)
#define GUSI_COMPLETION_PROC_A0(proc, type) \
	static pascal void proc##Entry(type * param : __A0) { proc(param); }
#define GUSI_COMPLETION_PROC_A1(proc, type) \
	static pascal void proc##Entry(type * param : __A1) { proc(param); }
#else
void * GUSIGetA0()  ONEWORDINLINE(0x2008);
void * GUSIGetA1()  ONEWORDINLINE(0x2009);
#define GUSI_COMPLETION_PROC_A0(proc, type) \
	static pascal void proc##Entry() 		\
		{ proc(reinterpret_cast<type *>(GUSIGetA0())); }
#define GUSI_COMPLETION_PROC_A1(proc, type) \
	static pascal void proc##Entry() 		\
		{ proc(reinterpret_cast<type *>(GUSIGetA1())); }
#endif
@ %define GUSI_COMPLETION_PROC_A0 GUSI_COMPLETION_PROC_A1

SC seems to have an issue with mutable fields. 
<<Definition of compiler features>>=
#if defined(__SC__)
#define mutable
#define GUSI_MUTABLE(class, field) const_cast<class *>(this)->field
#else
#define GUSI_MUTABLE(class, field) field
#endif
@

SC pretends to support standard scoping rules, but is in fact broken in
some cases.
<<Definition of compiler features>>=
#if defined(__SC__)
#define for	if (0) ; else for
#endif
@

The MPW compilers don't predeclare [[qd]].
<<Definition of compiler features>>=
#if defined(__SC__) || defined(__MRC__)
#define GUSI_NEEDS_QD	QDGlobals	qd;
#else
#define GUSI_NEEDS_QD	
#endif
@

\section{Definition of hook handling}

GUSI supports a number of hooks. Every one of them has a different prototype, 
but is passed as a [[GUSIHook]]. Hooks are encoded with an [[OSType]].
<<Definition of hook handling>>=
typedef unsigned long OSType;
typedef void (*GUSIHook)(void);
void GUSISetHook(OSType code, GUSIHook hook);
GUSIHook GUSIGetHook(OSType code);
@ %def GUSIHook GUSIGetHook GUSISetHook

Currently, three hooks are supported: [[GUSI_SpinHook]] defines a function to 
be called when GUSI waits on an event.
[[GUSI_ExecHook]] defines a function that determines whether a file is to be 
considered ``executable''. [[GUSI_EventHook]] defines a routine that is called
when a certain event happens. To install an event hook, pass [[GUSI_EventHook]]
plus the event code. A few events, that is mouse-down and high level events,
are handled automatically by GUSI. Passing [[-1]] for the hook disables default
handling of an event.
<<Definition of hook handling>>=
typedef bool	(*GUSISpinFn)(bool wait);
#define GUSI_SpinHook	'spin'

struct FSSpec;
typedef bool	(*GUSIExecFn)(const FSSpec * file);
#define GUSI_ExecHook	'exec'

struct EventRecord;
typedef void (*GUSIEventFn)(EventRecord * ev);
#define GUSI_EventHook	'evnt'
@ %def GUSISpinFn GUSI_SpinHook GUSIExecFn GUSI_ExecHook GUSIEventFn GUSI_EventHook

For the purposes of the functions who actually call the hooks, here's the direct
interface.
<<Definition of hook handling>>=
#ifdef GUSI_INTERNAL
extern GUSISpinFn	gGUSISpinHook;
extern GUSIExecFn	gGUSIExecHook;
#endif /* GUSI_INTERNAL */
@ %def gGUSISpinHook gGUSIExecHook

\section{Definition of error handling}

Like a good POSIX citizen, GUSI reports all errors in the [[errno]] global
variable. This happens either through the [[GUSISetPosixError]] routine, which
stores its argument untranslated, or through the [[GUSISetMacError]] routine,
which translates MacOS error codes into the correct POSIX codes. The mapping
of [[GUSISetMacError]] is not always appropriate, so some routines will have to
preprocess some error codes. [[GUSIMapMacError]] returns the POSIX error corresponding
to a MacOS error.

The domain name routines use an analogous variable [[h_errno]], which is 
manipulated with [[GUSISetHostError]] and [[GUSISetMacHostError]].

All routines return 0 if 0 was passed and -1 otherwise.
<<Definition of error handling>>=
typedef short OSErr;

int GUSISetPosixError(int error);
int GUSISetMacError(OSErr error);
int GUSIMapMacError(OSErr error);
int GUSISetHostError(int error);
int GUSISetMacHostError(OSErr error);
@ %def GUSISetPosixError GUSISetMacError GUSIMapMacError GUSISetHostError GUSISetMacHostError

POSIX routines should never set [[errno]] from nonzero to zero. On the other
hand, it's sometimes useful to see whether some particular region of the
program set the error code or not. Therefore, we have such regions allocate
a [[GUSIErrorSaver]] statically, which guarantees that previous error codes 
get restored if necessary.
<<Definition of error handling>>=
class GUSIErrorSaver {
public:
	GUSIErrorSaver()  		{ fSavedErrno = errno; errno = 0; 	}
	~GUSIErrorSaver() 		{ if (!errno) errno = fSavedErrno;  }
private:
	int fSavedErrno;
};
@ %def GUSIErrorSaver

\section{Definition of event handling}

[[GUSIHandleNextEvent]] events by calling handlers installed 
using the [[GUSI_EventHook]] mechanism. 
<<Definition of event handling>>=
void GUSIHandleNextEvent(long sleepTime);
@

\section{Definition of string formatting}

We occasionally need sprintf. To keep compatibility with MSL, Stdio, and Sfio, 
we use an internal version which can be overridden.
<<Definition of string formatting>>=
int GUSI_vsprintf(char * s, const char * format, va_list args);
int GUSI_sprintf(char * s, const char * format, ...);
@

\section{Implementation of hook handling}

Each hook is represented by a hook variable and a piece of code in the set and
get routine.
<<Implementation of hook handling>>=
__BEGIN_DECLS
<<Hook variables>>
__END_DECLS
void GUSISetHook(OSType code, GUSIHook hook)
{
	switch (code) {
	<<Hook setter code>>
	default:
		GUSI_ASSERT_CLIENT(0, 
			(	"Illegal code %lx ('%c%c%c%c') passed to GUSISetHook\n",
				code,
				(code >> 24) & 0xff,
				(code >> 16) & 0xff,
				(code >> 8)  & 0xff,
				(code) 		 & 0xff
			));
		break;		
	}
}
GUSIHook GUSIGetHook(OSType code)
{
	switch (code) {
	<<Hook getter code>>
	default:
		GUSI_ASSERT_CLIENT(0, 
			(	"Illegal code %lx ('%c%c%c%c') passed to GUSIGetHook\n",
				code,
				(code >> 24) & 0xff,
				(code >> 16) & 0xff,
				(code >> 8)  & 0xff,
				(code) 		 & 0xff
			));
		return (GUSIHook) nil;
	}
}
@

Every hook then has to add to the three above code sections. Here is the spin hook.
<<Hook variables>>=
GUSISpinFn gGUSISpinHook;
@
<<Hook setter code>>=
case GUSI_SpinHook:
	gGUSISpinHook = (GUSISpinFn) hook;
	break;
@
<<Hook getter code>>=
case GUSI_SpinHook:
	return (GUSIHook) gGUSISpinHook;
@

Here is the exec hook. I guess you see the pattern now
<<Hook variables>>=
GUSIExecFn gGUSIExecHook;
<<Hook setter code>>=
case GUSI_ExecHook:
	gGUSIExecHook = (GUSIExecFn) hook;
	break;
<<Hook getter code>>=
case GUSI_ExecHook:
	return (GUSIHook) gGUSIExecHook;
@

The event hook is somewhat different as it is a whole array of hooks.
<<Hook variables>>=
const short kGUSIDefaultEventMask = mDownMask+highLevelEventMask;
short		gGUSIEventMask		  = kGUSIDefaultEventMask;
GUSIEventFn	gGUSIEventHook[16];
<<Hook setter code>>=
case GUSI_EventHook + nullEvent:
case GUSI_EventHook + mouseDown:
case GUSI_EventHook + mouseUp:
case GUSI_EventHook + keyDown:
case GUSI_EventHook + keyUp:
case GUSI_EventHook + autoKey:
case GUSI_EventHook + updateEvt:
case GUSI_EventHook + diskEvt:
case GUSI_EventHook + activateEvt:
case GUSI_EventHook + osEvt:
	code -= GUSI_EventHook;
	if (hook == (GUSIHook) -1) {
		gGUSIEventHook[code] = (GUSIEventFn) 0;
		gGUSIEventMask &= ~(1 << code);
	} else {
		gGUSIEventHook[code] = (GUSIEventFn) hook;
		if (hook || kGUSIDefaultEventMask & (1 << code))
			gGUSIEventMask |= 1 << code;
		else
			gGUSIEventMask &= ~(1 << code);
	}
	break;
case GUSI_EventHook + kHighLevelEvent:
	if (hook != (GUSIHook) -1)
		gGUSIEventMask |= highLevelEventMask;
	else
		gGUSIEventMask &= ~highLevelEventMask;
	break;
@
<<Hook getter code>>=
case GUSI_EventHook + nullEvent:
case GUSI_EventHook + mouseDown:
case GUSI_EventHook + mouseUp:
case GUSI_EventHook + keyDown:
case GUSI_EventHook + keyUp:
case GUSI_EventHook + autoKey:
case GUSI_EventHook + updateEvt:
case GUSI_EventHook + diskEvt:
case GUSI_EventHook + activateEvt:
case GUSI_EventHook + osEvt:
	return (GUSIHook) gGUSIEventHook[code - GUSI_EventHook];
case GUSI_EventHook + kHighLevelEvent:
	return (GUSIHook) ((gGUSIEventMask & highLevelEventMask) ? 0 : -1);
@

\section{Implementation of error handling}

<<Implementation of error handling>>=
int GUSISetPosixError(int error)
{
	if (error > 0) {
		errno = error;
		
		return -1;
	} else if (error < 0) {
		errno = EINVAL;
		
		return -1;
	} else
		return 0;
}
@

<<Implementation of error handling>>=
inline int GUSIErrorMapping(OSErr error, int posixError)
{
	GUSI_MESSAGE(("Error MacOS %d -> POSIX %d\n", error, posixError));
	return posixError;
}

int GUSIMapMacError(OSErr error)
{
	switch (error) {
	case noErr:
		return 0;
	<<Map File Manager errors to POSIX errors>>
	<<Map MacTCP errors to POSIX errors>>
	<<Map Open Transport errors to POSIX errors>>
	<<Map PPC Toolbox errors to POSIX errors>>
	case memFullErr:
		return GUSIErrorMapping(error, ENOMEM);
	default:
		return GUSIErrorMapping(error, EINVAL);
	}
}

int GUSISetMacError(OSErr error)
{
	return GUSISetPosixError(GUSIMapMacError(error));
}
@

The errors we handle originate mainly from four major sources. The first
of them is the File Manager.
<<Map File Manager errors to POSIX errors>>=
case opWrErr:
case wrPermErr:
	return GUSIErrorMapping(error, EPERM);
case bdNamErr:
	return GUSIErrorMapping(error, ENAMETOOLONG);
case afpObjectTypeErr:
	return GUSIErrorMapping(error, ENOTDIR);
case fnfErr:
case nsvErr:
case dirNFErr:
	return GUSIErrorMapping(error, ENOENT);
case dupFNErr:
	return GUSIErrorMapping(error, EEXIST);
case dirFulErr:
case dskFulErr:
	return GUSIErrorMapping(error, ENOSPC);
case fBsyErr:
	return GUSIErrorMapping(error, EBUSY);
case tmfoErr:
	return GUSIErrorMapping(error, ENFILE);
case fLckdErr:
case permErr:
case afpAccessDenied:
case kOTAccessErr:			/* -3152 Missing access permission					*/
	return GUSIErrorMapping(error, EACCES);
case wPrErr:
case vLckdErr:
	return GUSIErrorMapping(error, EROFS);
case badMovErr:
	return GUSIErrorMapping(error, EINVAL);
case diffVolErr:
	return GUSIErrorMapping(error, EXDEV);
@

MacTCP generates another group of errors.
<<Map MacTCP errors to POSIX errors>>=
case openFailed:
	return GUSIErrorMapping(error, ECONNREFUSED);
case duplicateSocket:
	return GUSIErrorMapping(error, EADDRINUSE);
case connectionTerminated:
	return GUSIErrorMapping(error, ECONNREFUSED);
case commandTimeout:
	return GUSIErrorMapping(error, ETIMEDOUT);		
case ipBadLapErr:
case ipBadCnfgErr:
case ipNoCnfgErr:
case ipLoadErr:
	return GUSIErrorMapping(error, ENETDOWN);
@

Open Transport both generates its own version of many
POSIX error codes and a number of ``native'' error codes.
<<Map Open Transport errors to POSIX errors>>=
case kOTLookErr:			/* -3158 An event occurred - call Look() 			*/
	return GUSIErrorMapping(error, ELOOK);
case kOTAddressBusyErr:		/* -3172 Address requested is already in use		*/
	return GUSIErrorMapping(error, EADDRINUSE);
case kOTNoAddressErr:		/* -3154 No address was specified					*/
case kOTOutStateErr:		/* -3155 Call issued in wrong state					*/
	return GUSIErrorMapping(error, ENOTCONN);
case kOTFlowErr:			/* -3161 Provider is flow-controlled				*/
	return GUSIErrorMapping(error, EWOULDBLOCK);
case kOTNotSupportedErr:	/* -3167 Command is not supported					*/
	return GUSIErrorMapping(error, EOPNOTSUPP);
case kOTCanceledErr:		/* -3180 The command was cancelled					*/
	return GUSIErrorMapping(error, ECANCELED);
case kEAGAINErr:		/*  Seems to be returned for refused connections	*/
	return GUSIErrorMapping(error, ECONNREFUSED);
<<Map Open Transport POSIXish errors to POSIX errors>>
@

A little macro provides a great service in translating the POSIXish OpenTransport errors.
<<Map Open Transport POSIXish errors to POSIX errors>>=
#define MAP_OT_POSIX_ERROR(err)	case k##err##Err: return err

MAP_OT_POSIX_ERROR(EPERM);			/*  Permission denied					*/
MAP_OT_POSIX_ERROR(ENOENT);			/*  No such file or directory			*/
MAP_OT_POSIX_ERROR(EINTR);			/*  Interrupted system service			*/
MAP_OT_POSIX_ERROR(EIO);			/*  I/O error							*/
MAP_OT_POSIX_ERROR(ENXIO);			/*  No such device or address			*/
MAP_OT_POSIX_ERROR(EBADF);			/*  Bad file number						*/
MAP_OT_POSIX_ERROR(ENOMEM);			/*  Not enough space					*/
MAP_OT_POSIX_ERROR(EACCES);			/*  Permission denied					*/
MAP_OT_POSIX_ERROR(EFAULT);			/*  Bad address							*/
MAP_OT_POSIX_ERROR(EBUSY);			/*  Device or resource busy				*/
MAP_OT_POSIX_ERROR(EEXIST);			/*  File exists							*/
MAP_OT_POSIX_ERROR(ENODEV);			/*  No such device						*/
MAP_OT_POSIX_ERROR(EINVAL);			/*  Invalid argument					*/
MAP_OT_POSIX_ERROR(ENOTTY);			/*  Not a character device				*/
MAP_OT_POSIX_ERROR(EPIPE);			/*  Broken pipe							*/
MAP_OT_POSIX_ERROR(ERANGE);			/*  Message size too large for STREAM	*/
MAP_OT_POSIX_ERROR(EWOULDBLOCK);	/* 										*/
MAP_OT_POSIX_ERROR(EALREADY);		/* 										*/
MAP_OT_POSIX_ERROR(ENOTSOCK);		/*  Socket operation on non-socket		*/
MAP_OT_POSIX_ERROR(EDESTADDRREQ);	/*  Destination address required		*/
MAP_OT_POSIX_ERROR(EMSGSIZE);		/*  Message too long					*/
MAP_OT_POSIX_ERROR(EPROTOTYPE);		/*  Protocol wrong type for socket		*/
MAP_OT_POSIX_ERROR(ENOPROTOOPT);	/*  Protocol not available				*/
MAP_OT_POSIX_ERROR(EPROTONOSUPPORT);/*  Protocol not supported				*/
MAP_OT_POSIX_ERROR(ESOCKTNOSUPPORT);/*  Socket type not supported			*/
MAP_OT_POSIX_ERROR(EOPNOTSUPP);		/*  Operation not supported on socket	*/
MAP_OT_POSIX_ERROR(EADDRINUSE);		/*  Address already in use				*/
MAP_OT_POSIX_ERROR(EADDRNOTAVAIL);	/*  Can't assign requested address		*/
MAP_OT_POSIX_ERROR(ENETDOWN);		/*  Network is down						*/
MAP_OT_POSIX_ERROR(ENETUNREACH);	/*  Network is unreachable				*/
MAP_OT_POSIX_ERROR(ENETRESET);		/*  Network dropped connection on reset	*/
MAP_OT_POSIX_ERROR(ECONNABORTED);	/*  Software caused connection abort	*/
MAP_OT_POSIX_ERROR(ECONNRESET);		/*  Connection reset by peer			*/
MAP_OT_POSIX_ERROR(ENOBUFS);		/*  No buffer space available			*/
MAP_OT_POSIX_ERROR(EISCONN);		/*  Socket is already connected			*/
MAP_OT_POSIX_ERROR(ENOTCONN);		/*  Socket is not connected				*/
MAP_OT_POSIX_ERROR(ESHUTDOWN);		/*  Can't send after socket shutdown	*/
MAP_OT_POSIX_ERROR(ETOOMANYREFS);	/*  Too many references: can't splice	*/
MAP_OT_POSIX_ERROR(ETIMEDOUT);		/*  Connection timed out				*/
MAP_OT_POSIX_ERROR(ECONNREFUSED);	/*  Connection refused					*/
MAP_OT_POSIX_ERROR(EHOSTDOWN);		/*  Host is down						*/
MAP_OT_POSIX_ERROR(EHOSTUNREACH);	/*  No route to host					*/
MAP_OT_POSIX_ERROR(EINPROGRESS);	/* 										*/
MAP_OT_POSIX_ERROR(ESRCH);			/* 										*/
@

Finally, the PPC Toolbox generates some errors.
<<Map PPC Toolbox errors to POSIX errors>>=
case destPortErr:      		/* -906 Port does not exist at destination*/		
	return GUSIErrorMapping(error, EADDRNOTAVAIL);
case portNameExistsErr: 	/* -910 port is already open (perhaps in another app)*/
	return GUSIErrorMapping(error, EISCONN);
case userRejectErr: 		/* -912 Destination rejected the session request*/
	return GUSIErrorMapping(error, ECONNREFUSED);
case noResponseErr: 		/* -916 unable to contact destination*/
	return GUSIErrorMapping(error, ENETUNREACH);
@

[[h_errno]] is defined here.
<<Implementation of error handling>>=
int h_errno;

int GUSISetHostError(int error)
{
	if (error) {
		h_errno = error;
		
		return -1;
	} else
		return 0;
}

int GUSISetMacHostError(OSErr error)
{
	switch (error) {
	case noErr: 
		return 0;
	case nameSyntaxErr:
	case noNameServer:
	case authNameErr:
		h_errno = HOST_NOT_FOUND;	
		break;
	case noResultProc:
	case dnrErr:
	default:
		h_errno = NO_RECOVERY;
		break;
	case noAnsErr:
	case outOfMemory:
		h_errno = TRY_AGAIN;
		break;
	}
	return -1;
}
@ %def h_errno

\section{Implementation of event handling}

<<Implementation of event handling>>=
void GUSIHandleNextEvent(long sleepTime)
{
	EventRecord event;
	
	if (WaitNextEvent(gGUSIEventMask|1, &event, sleepTime, nil))
		switch (event.what) {
		case mouseDown:
			if (!gGUSIEventHook[mouseDown]) {
				WindowPtr win;
				if (FindWindow(event.where, &win) == inSysWindow)
					SystemClick(&event, win);
				return;
			}
			break;
		case kHighLevelEvent:
			AEProcessAppleEvent(&event);	// Ignore errors
				
			return;
		}

	if (gGUSIEventHook[event.what])
		gGUSIEventHook[event.what](&event);
}
@

\section{Implementation of string formatting}

<<Implementation of string formatting>>=
int GUSI_vsprintf(char * s, const char * format, va_list args)
{
	return vsprintf(s, format, args);
}

int GUSI_sprintf(char * s, const char * format, ...)
{
	va_list	ap;
		
	va_start(ap, format);
	int len = GUSI_vsprintf(s, format, ap);
	va_end(ap);
	
	return len;
}
@
