%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Project	:	GUSI				-	Grand Unified Socket Interface
% File		:	GUSIFileSpec.nw		-	File specifications
% Author	:	Matthias Neeracher
% Language	:	C++
% 
% $Log: GUSIFileSpec.nw,v $
% Revision 1.21  2002/09/02 06:35:30  neeri
% Fix infinite recursion in rename [MacPerl Bug #561694]
%
% Revision 1.20  2002/02/04 07:37:59  neeri
% Empty path is ENOENT (MacPerl Bug #512351)
%
% Revision 1.19  2001/04/16 01:50:02  neeri
% Fix GUSIFSpGetCatInfo (MacPerl bug #232702); Fix parsing of absolute paths with embedded aliases.
%
% Revision 1.18  2001/04/01 07:40:15  neeri
% Fix :::paths (MacPerl Bug #409940)
%
% Revision 1.17  2001/03/20 02:34:22  neeri
% Commented out false friends
%
% Revision 1.16  2001/03/09 09:20:53  neeri
% Fixed major bugs in relative path generation
%
% Revision 1.15  2001/01/17 08:46:45  neeri
% Get rid of excess directory seperators when name is empty
%
% Revision 1.14  2000/12/23 06:10:17  neeri
% Add GUSIFSpTouchFolder, GUSIFSpGetCatInfo; copy error in copy constructor
%
% Revision 1.13  2000/10/16 03:59:36  neeri
% Make FSSpec a member of GUSIFileSpec instead of a base class
%
% Revision 1.12  2000/06/12 04:20:58  neeri
% Introduce GUSI_*printf
%
% Revision 1.11  2000/05/23 07:00:00  neeri
% Improve formatting
%
% Revision 1.10  2000/03/15 07:16:08  neeri
% Fix path construction, temp name bugs
%
% Revision 1.9  2000/03/06 06:34:11  neeri
% Added C FSSpec convenience calls
%
% Revision 1.8  1999/08/26 05:45:02  neeri
% Fixes for literate edition of source code
%
% Revision 1.7  1999/07/19 06:21:02  neeri
% Add mkdir/rmdir, fix various file manager related bugs
%
% Revision 1.6  1999/06/28 06:00:53  neeri
% add support for generating temp names from basename
%
% Revision 1.5  1999/05/30 02:16:53  neeri
% Cleaner definition of GUSICatInfo
%
% Revision 1.4  1999/03/17 09:05:07  neeri
% Added GUSITimer, expanded docs
%
% Revision 1.3  1998/10/11 16:45:15  neeri
% Ready to release 2.0a2
%
% Revision 1.2  1998/08/01 21:32:04  neeri
% About ready for 2.0a1
%
% Revision 1.1  1998/01/25 21:02:46  neeri
% Engine implemented, except for signals & scheduling
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{File specifications}

While the Macintosh toolbox has a convenient type [[FSSpec]] to pass to
file system routines, it lacks manipulation functions. We provide them here.
This module has been known under a different name and with different data types
in GUSI 1.
<<GUSIFileSpec.h>>=
#ifndef _GUSIFileSpec_
#define _GUSIFileSpec_

#include <MacTypes.h>
#include <Files.h>
#include <Folders.h>

#include <string.h>
#include <sys/cdefs.h>

__BEGIN_DECLS
<<Plain C interfaces to [[GUSIFileSpec]]>>
__END_DECLS

#ifdef GUSI_SOURCE

#include "GUSIBasics.h"
#include "GUSIContext.h"

#include <ConditionalMacros.h>

#if PRAGMA_STRUCT_ALIGN
#pragma options align=native
#endif

<<Definition of class [[GUSICatInfo]]>>
<<Definition of class [[GUSIFileSpec]]>>

#if PRAGMA_STRUCT_ALIGN
#pragma options align=reset
#endif

<<Inline member functions for class [[GUSICatInfo]]>>
<<Inline member functions for class [[GUSIFileSpec]]>>

#endif /* GUSI_SOURCE */

#endif /* GUSIFileSpec */
@

<<GUSIFileSpec.cp>>=
#include "GUSIInternal.h"
#include "GUSIFileSpec.h"
#include "GUSIFSWrappers.h"

#include <PLStringFuncs.h>
#include <Errors.h>
#include <TextUtils.h>
#include <Resources.h>
#include <Memory.h>
#include <Aliases.h>

#include <ctype.h>
#include <stdlib.h>
#include <stdio.h>

<<Auxiliary functions for class [[GUSIFileSpec]]>>
<<Member functions for class [[GUSIFileSpec]]>>
<<C API functions for [[GUSIFileSpec]]>>
@

\section{C Interfaces to [[GUSIFileSpec]]}

Many of the API routines defined here are useful to C code and not too hard to make accessible,
even though I prefer the C++ versions. As opposed to GUSI 1, we stick to our namespace now.
<<Plain C interfaces to [[GUSIFileSpec]]>>=
/*
 * Construct a FSSpec from...
 */
/* ... the refNum of an open file. 		*/
OSErr GUSIFRefNum2FSp(short fRefNum, FSSpec * desc);
/* ... a working directory & file name. */
OSErr GUSIWD2FSp(short wd, ConstStr31Param name, FSSpec * desc);
/* ... a path name.						*/
OSErr GUSIPath2FSp(const char * path, FSSpec * desc);	
/* ... a special object. 				*/
OSErr GUSISpecial2FSp(OSType object, short vol, FSSpec * desc);	
/* ... a temporary file path.		    */
OSErr GUSIMakeTempFSp(short vol, long dirID, FSSpec * desc);

/*
 * Convert a FSSpec into...
 */
/* ... a full path name.								*/
char * GUSIFSp2FullPath(const FSSpec * desc);
/* ... a relative path name if possible, full if not 	*/
char * GUSIFSp2RelPath(const FSSpec * desc);	
/* ... a path relative to the specified directory 		*/
char * GUSIFSp2DirRelPath(const FSSpec * desc, const FSSpec * dir);
/* ... an GUSI-=specific ASCII encoding. 				*/
char * GUSIFSp2Encoding(const FSSpec * desc);

/*
 * Construct FSSpec of...
 */
/* ... (vRefNum, parID) */
OSErr GUSIFSpUp(FSSpec * desc);
/* ... file (name) in directory denoted by desc */
OSErr GUSIFSpDown(FSSpec * desc, ConstStr31Param name);
/* ... of nth file in directory denoted by (vRefNum, parID) */
OSErr GUSIFSpIndex(FSSpec * desc, short n);

/* Resolve if alias file */
OSErr GUSIFSpResolve(FSSpec * spec);

/* Touch folder containing the object */
OSErr GUSIFSpTouchFolder(const FSSpec * spec);

/* Get catalog information (after resolving leaf aliases) */
OSErr GUSIFSpGetCatInfo(FSSpec * spec, CInfoPBRec * info);
@ %def GUSIFRefNum2FSp GUSIWD2FSp GUSIPath2FSp GUSISpecial2FSp GUSIFSp2FullPath GUSIFSp2RelPath 
@ %def GUSIFSp2DirRelPath GUSIFSp2Encoding GUSIFSpUp GUSIFSpDown GUSIFSpIndex GUSIFSpResolve
@ %def GUSIFSpTouchFolder GUSIFSpGetCatInfo

\section{Definition of [[GUSICatInfo]]}

[[GUSICatInfo]] is a wrapper for [[CInfoPBRec]]. Since the latter is a [[union]], we cannot
inherit from it.
<<Definition of class [[GUSICatInfo]]>>=
class GUSICatInfo {
	CInfoPBRec	fInfo;
public:
	bool		IsFile() const;
	bool		IsAlias() const;
	bool 		DirIsExported() const;
	bool	 	DirIsMounted() const;
	bool	 	DirIsShared() const;
	bool	 	HasRdPerm() const;
	bool 		HasWrPerm() const;
	bool 		Locked() const;
	
	CInfoPBRec &				Info()			{	return fInfo; 							}
	operator CInfoPBRec &()						{	return fInfo; 							}
	struct HFileInfo &			FileInfo()		{	return fInfo.hFileInfo;					}
	struct DirInfo &			DirInfo()		{	return fInfo.dirInfo;					}
	struct FInfo &				FInfo()			{	return fInfo.hFileInfo.ioFlFndrInfo;	}
	struct FXInfo &				FXInfo()		{	return fInfo.hFileInfo.ioFlXFndrInfo;	}
	
	const CInfoPBRec &			Info() const	{	return fInfo; 							}
	operator const CInfoPBRec &()	const		{	return fInfo; 							}
	const struct HFileInfo &	FileInfo() const{	return fInfo.hFileInfo;					}
	const struct DirInfo &		DirInfo() const	{	return fInfo.dirInfo;					}
	const struct FInfo &		FInfo() const	{	return fInfo.hFileInfo.ioFlFndrInfo;	}
	const struct FXInfo &		FXInfo() const	{	return fInfo.hFileInfo.ioFlXFndrInfo;	}
};
@ %def GUSICatInfo


\section{Definition of [[GUSIFileSpec]]}

A [[GUSIFileSpec]] is a manipulation friendly version of an [[FSSpec]]. Due to
conversion operators, a [[GUSIFileSpec]] can be used whereever a [[const FSSpec]]
is specified. For any long term storage, [[FSSpec]] should be used rather than the
much bulkier [[GUSIFileSpec]].
<<Definition of class [[GUSIFileSpec]]>>=
class GUSIFileSpec {
public:
	<<Constructors for [[GUSIFileSpec]]>>
	<<Error handling in [[GUSIFileSpec]]>>
	<<Default directory handling in [[GUSIFileSpec]]>>
	<<Converting a [[GUSIFileSpec]] to a [[FSSpec]]>>
	<<Getting the [[GUSICatInfo]] for a [[GUSIFileSpec]]>>
	<<Getting path names from a [[GUSIFileSpec]]>>
	<<Alias resolution for a [[GUSIFileSpec]]>>
	<<Manipulating a [[GUSIFileSpec]]>>
	<<Comparing two [[GUSIFileSpec]] objects>>
protected:
	<<Privatissima of [[GUSIFileSpec]]>>
};
@ %def GUSIFileSpec

A [[GUSIFileSpec]] can be constructed in lots of different ways. Most of the 
constructors have a final argument [[useAlias]] that, when [[true]], suppresses
resolution of leaf aliases.

First, two trivial cases: The default constructor and the copy constructor, which
do exactly what you'd expect them to do.
<<Constructors for [[GUSIFileSpec]]>>=
GUSIFileSpec()	{}
GUSIFileSpec(const GUSIFileSpec & spec);
@

The [[FSSpec]] conversion is almost a copy constructor, but by default resolves
leaf aliases.
<<Constructors for [[GUSIFileSpec]]>>=
GUSIFileSpec(const FSSpec & spec, bool useAlias = false);
@

A number of convenience constructors let you construct a [[GUSIFileSpec]] from
various components.
<<Constructors for [[GUSIFileSpec]]>>=
// Construct from volume reference number, directory ID & file name
GUSIFileSpec(short vRefNum, long parID, ConstStr31Param name, bool useAlias = false);

// Construct from working directory & file name
GUSIFileSpec(short wd, ConstStr31Param name, bool useAlias = false);

// Construct from full or relative path
GUSIFileSpec(const char * path, bool useAlias = false);
	
// Construct from open file reference number
explicit GUSIFileSpec(short fRefNum);
@

Finally, there is a constructor for constructing a [[GUSIFileSpec]] for one of
the folders obtainable with [[FindFolder]].
<<Constructors for [[GUSIFileSpec]]>>=
GUSIFileSpec(OSType object, short vol = kOnSystemDisk);
@

All [[GUSIFileSpecs]] have an error variable from which the last error
is available.
<<Error handling in [[GUSIFileSpec]]>>=
OSErr		Error() const;
			operator void*() const;
bool		operator!() const;
@

While earlier versions of GUSI maintained a notion of "current directory" that
was independent of the HFS default directory, there is no such distinction anymore
in GUSI 2. [[SetDefaultDirectory]] sets the default directory to [[vRefNum, dirID]].
[[GetDefaultDirectory]] sets [[vRefNum,dirID]] to the default directory. Neither
routine affects the [[name]]. [[GetVolume]] gets the named or indexed volume.
<<Default directory handling in [[GUSIFileSpec]]>>=
OSErr	SetDefaultDirectory();
OSErr	GetDefaultDirectory();
OSErr	GetVolume(short index = -1);
@

Conversions of [[GUSIFileSpec]] to [[FSSpec]] values and references is, of course, 
simple. Pointers are a bit trickier; we define an custom [[operator&]] and two 
smart pointer classes. [[operator->]], however, is simpler.
<<Converting a [[GUSIFileSpec]] to a [[FSSpec]]>>=
operator const FSSpec &() const;

class pointer {
public:
	pointer(GUSIFileSpec * ptr);
	operator GUSIFileSpec *() const;
	operator const FSSpec *() const;
private:
	GUSIFileSpec * ptr;
};
pointer operator&();

class const_pointer {
public:
	const_pointer(const GUSIFileSpec * ptr);
	operator const GUSIFileSpec *() const;
	operator const FSSpec *() const;
private:
	const GUSIFileSpec * ptr;
};
const_pointer operator&() const;

const FSSpec * operator->() const;

friend class pointer;
friend class const_pointer;
@

Each [[GUSIFileSpec]] has an implicit [[GUSICatInfo]] record associated with it.
[[CatInfo]] calls [[GetCatInfo]] if the record is not already valid and
returns a pointer to the record. [[DirInfo]] replaces the [[GUSIFileSpec]] by 
the specification of its parent directory and returns a pointer to information 
about the parent. Both calls return a [[nil]] pointer if the object does not exist.
If all you are interested in is whether the object exists, call [[Exists]]. If
external circumstances invalidate the information, call [[ResetCatInfo]].
<<Getting the [[GUSICatInfo]] for a [[GUSIFileSpec]]>>=
const GUSICatInfo * CatInfo(short index);
const GUSICatInfo * DirInfo();
const GUSICatInfo * CatInfo() const;
bool				Exists() const;
void				ResetCatInfo() const;
@

In many POSIXish contexts, it's necessary to specify path names with C string. 
Although this practice is dangerous on a Mac, we of course have to conform to
it. The basic operations are getting a full path and getting a path relative to
a directory (the current directory by default).
<<Getting path names from a [[GUSIFileSpec]]>>=
char *	FullPath() const;
char *	RelativePath() const;
char *	RelativePath(const FSSpec & dir) const;
@

If the path ultimately is going to flow back into a GUSI routine again, it is 
possible to simply encode the [[GUSIFileSpec]] in ASCII. This is fast and reliable,
but you should of course not employ it with any non-GUSI destination routine and 
should never store such a part across a reboot. The standard [[GUSIFileSpec]] 
constructors for paths will accept encoded paths.

The encoding is defined as:

\begin{itemize}
\item 1 byte:   DC1  (ASCII 0x11)
\item 4 bytes:  Volume reference number in zero-padded hex
\item 8 bytes:  Directory ID in zero-padded hex
\item n bytes:  Partial pathname, starting with ':'
\end{itemize}
<<Getting path names from a [[GUSIFileSpec]]>>=
char *	EncodedPath() const;
@

Most aliases are resolved implicitly, but occasionally you may want to do
explicit resolution. [[Resolve]] resolves an alias. If [[gently]] is set, 
nonexistent target files of aliases don't cause an error to be returned.
<<Alias resolution for a [[GUSIFileSpec]]>>=
OSErr	Resolve(bool gently = true);
@

[[AliasPath]] returns the path an alias points to without mounting any volumes. 
<<Alias resolution for a [[GUSIFileSpec]]>>=
char *	AliasPath() const;
@

A major feature of the [[GUSIFileSpec]] class is the set of operators for
manipulating a file specification.

[[operator--]] replaces a file specification with the directory specification of
its parent.
<<Manipulating a [[GUSIFileSpec]]>>=
GUSIFileSpec &	operator--();
@

[[operator++]] sets the [[dirID]] of a directory specification to the ID of the
directory.
<<Manipulating a [[GUSIFileSpec]]>>=
GUSIFileSpec &	operator++();
@

The two versions of [[operator+=]], which internally both call [[AddPathComponent]],
replace a directory specification with the specification
<<Manipulating a [[GUSIFileSpec]]>>=
GUSIFileSpec &	AddPathComponent(const char * name, int length, bool fullSpec);
GUSIFileSpec &	operator+=(ConstStr31Param name);
GUSIFileSpec &	operator+=(const char * name);
@

[[operator+]] provides a non-destructive variant of [[operator+=]].
<<Manipulating a [[GUSIFileSpec]]>>=
//
// These don't need access to the GUSIFileSpec internals
//
// friend GUSIFileSpec operator+(const FSSpec & spec, ConstStr31Param name);
// friend GUSIFileSpec operator+(const FSSpec & spec, const char * name);
@

Array access replaces the file specification with the [[index]]th object in the
{\em parent directory} of the specification (allowing the same specification to
be reused for reading a directory).
<<Manipulating a [[GUSIFileSpec]]>>=
GUSIFileSpec & operator[](short index);
@

To manipulate the fields of the file specification directly, there is a procedural
interface.
<<Manipulating a [[GUSIFileSpec]]>>=
void SetVRef(short vref);
void SetParID(long parid);
void SetName(ConstStr63Param nam);
void SetName(const char * nam);
@

For some modifications to propagate quickly, the surrounding folder needs to 
have its date modified.
<<Manipulating a [[GUSIFileSpec]]>>=
OSErr TouchFolder();
@

Two [[GUSIFileSpecs]] can be compared for (in)equality.
<<Comparing two [[GUSIFileSpec]] objects>>=
friend bool operator==(const GUSIFileSpec & one, const GUSIFileSpec & other);
@

[[IsParentOf]] determines whether the object specifies a parent directory of 
[[other]].
<<Comparing two [[GUSIFileSpec]] objects>>=
bool	IsParentOf(const GUSIFileSpec & other) const;
@

A [[GUSITempFileSpec]] is just a [[GUSIFileSpec]] with constructors to construct
filenames for temporary files.
<<Definition of class [[GUSIFileSpec]]>>=
class GUSITempFileSpec : public GUSIFileSpec {
public:
	GUSITempFileSpec(short vRefNum = kOnSystemDisk);
	GUSITempFileSpec(short vRefNum, long parID);
	GUSITempFileSpec(ConstStr31Param basename);
	GUSITempFileSpec(short vRefNum, ConstStr31Param basename);
	GUSITempFileSpec(short vRefNum, long parID, ConstStr31Param basename);
private:
	void TempName();
	void TempName(ConstStr31Param basename);
	
	static int	sID;
};
@ %def GUSITempFileSpec

\section{Implementation of [[GUSICatInfo]]}

All of the member functions for [[GUSICatInfo]] are inline.
<<Inline member functions for class [[GUSICatInfo]]>>=
inline bool GUSICatInfo::IsFile() const
{
	return !(DirInfo().ioFlAttrib & 0x10);
}

inline bool GUSICatInfo::IsAlias() const
{
	return
		!(FileInfo().ioFlAttrib & 0x10) &&
		(FInfo().fdFlags & (1 << 15));
}

inline bool GUSICatInfo::DirIsExported() const
{
	return (FileInfo().ioFlAttrib & 0x20) != 0;
}

inline bool GUSICatInfo::DirIsMounted() const
{
	return (FileInfo().ioFlAttrib & 0x08) != 0;
}

inline bool GUSICatInfo::DirIsShared() const
{
	return (FileInfo().ioFlAttrib & 0x04) != 0;
}

inline bool GUSICatInfo::HasRdPerm() const
{
	return !(DirInfo().ioACUser & 0x02) != 0;
}

inline bool GUSICatInfo::HasWrPerm() const
{
	return !(DirInfo().ioACUser & 0x04) != 0;
}

inline bool GUSICatInfo::Locked() const
{
	return (FileInfo().ioFlAttrib & 0x11) == 0x01;
}
@

\section{Implementation of [[GUSIFileSpec]]}

[[sError]] contains the error code for failed calls. [[Error]] returns the value.
<<Privatissima of [[GUSIFileSpec]]>>=
mutable OSErr	fError;
<<Inline member functions for class [[GUSIFileSpec]]>>=
inline OSErr GUSIFileSpec::Error() const
{
	return fError;
}

inline GUSIFileSpec::operator void*() const
{
	return (void *)!fError;
}

inline bool GUSIFileSpec::operator!() const
{
	return fError!=0;
}
@

For path name constructions, a sometimes large scratch area is needed which is 
maintained in [[sScratch]]. A scratch request preserves a preexisting scratch area
at the {\em end} of the new area if [[extend]] is nonzero.
<<Privatissima of [[GUSIFileSpec]]>>=
static char *		sScratch;
static long			sScratchSize;

static char *		CScratch(bool extend = false);
static StringPtr	PScratch();
<<Member functions for class [[GUSIFileSpec]]>>=
char *	GUSIFileSpec::sScratch;
long	GUSIFileSpec::sScratchSize;
<<Inline member functions for class [[GUSIFileSpec]]>>=
inline StringPtr GUSIFileSpec::PScratch()
{
	return (StringPtr) CScratch();
}
<<Member functions for class [[GUSIFileSpec]]>>=
char * GUSIFileSpec::CScratch(bool extend)
{
	if (extend) {
		char * newScratch = NewPtr(sScratchSize + 64);
		if (!newScratch)
			return nil;
		BlockMoveData(sScratch, newScratch+64, sScratchSize);
		sScratchSize += 64;
		DisposePtr(sScratch);
		
		return sScratch = newScratch;
	} else if (!sScratchSize)
		if (sScratch = NewPtr(256))
			sScratchSize = 256;

	return sScratch;
}
@

A [[GUSIFileSpec]] has a [[GUSICatInfo]] embedded and a flag [[fValidInfo]] indicating
that it is valid. 
<<Privatissima of [[GUSIFileSpec]]>>=
FSSpec							fSpec;
GUSIIOPBWrapper<GUSICatInfo>	fInfo;
mutable bool					fValidInfo;
<<Member functions for class [[GUSIFileSpec]]>>=
GUSIFileSpec::GUSIFileSpec(const GUSIFileSpec & spec)
	: fValidInfo(false), fSpec(spec.fSpec), fError(spec.fError)
{
}
@

<<Member functions for class [[GUSIFileSpec]]>>=
GUSIFileSpec::GUSIFileSpec(const FSSpec & spec, bool useAlias)							
	: fValidInfo(false), fSpec(spec), fError(noErr)
{
	if (!useAlias)
		Resolve();
}
@

<<Member functions for class [[GUSIFileSpec]]>>=
GUSIFileSpec::GUSIFileSpec(short vRefNum, long parID, ConstStr31Param name, bool useAlias)
	: fValidInfo(false)
{
	OSErr	err;
	
	if ((err = FSMakeFSSpec(vRefNum, parID, name, &fSpec)) && (err != fnfErr)) {
		fSpec.vRefNum	=	vRefNum;
		fSpec.parID		=	parID;
		memcpy(fSpec.name, name, *name+1);
	}
	fError	= noErr;
	
	if (!useAlias)
		Resolve();	
		
	if (EqualString(fSpec.name, name, false, true))
		memcpy(fSpec.name, name, *name+1);		
}
@

<<Member functions for class [[GUSIFileSpec]]>>=
GUSIFileSpec::GUSIFileSpec(short wd, ConstStr31Param name, bool useAlias)
	: fValidInfo(false)
{
	if ((fError = FSMakeFSSpec(wd, 0, name, &fSpec)) && (fError != fnfErr))
		return;
	
	if (!useAlias)
		Resolve();
		
	if (EqualString(fSpec.name, name, false, true))
		memcpy(fSpec.name, name, *name+1);		
}
@

<<Member functions for class [[GUSIFileSpec]]>>=
GUSIFileSpec::GUSIFileSpec(OSType object, short vol)
	: fValidInfo(false)
{
	fError = FindFolder(vol, object, true, &fSpec.vRefNum, &fSpec.parID);
}
@

<<Member functions for class [[GUSIFileSpec]]>>=
GUSIFileSpec::GUSIFileSpec(short fRefNum)
	: fValidInfo(false)
{
	GUSIIOPBWrapper<FCBPBRec>	fcb;

	fcb->ioNamePtr	= 	fSpec.name;
	fcb->ioRefNum	=	fRefNum;
	fcb->ioFCBIndx	= 	0;

	if (fError = GUSIFSGetFCBInfo(&fcb))
		return;

	fSpec.vRefNum 	=	fcb->ioFCBVRefNum;
	fSpec.parID		=	fcb->ioFCBParID;
}
@

The pathname constructor is by far the most complex constructor. This code is also
probably not portable to Rhapsody, whatever and whenever that will be.

To minimize the number of [[CatInfo]] calls necessary, the [[fullSpec]] variable
reflects whether the entire [[FSSpec]] under construction or only the [[vRefNum]]
and [[parID]] are valid.
<<Member functions for class [[GUSIFileSpec]]>>=
GUSIFileSpec::GUSIFileSpec(const char * path, bool useAlias)
	: fValidInfo(false)
{
	if (!*path) {
		fError = dirNFErr;
		return;
	}
	const char *	nextPath;
	bool			fullSpec	= 	false;
	
	fSpec.vRefNum 	= 0;
	fSpec.parID		= 0;
	
	<<Try decoding the path as an encoded [[FSSpec]]>>
	<<Try converting the path with [[FSMakeFSSpec]] and [[return]]>>
	<<Determine the starting directory of the path>>

	fError = noErr;
	while (*path && !fError) {
		if (*path == ':')	{
			<<Walk directories upwards>>
		} else {
			if (nextPath = strchr(path, ':')) {
				AddPathComponent(path, nextPath-path, fullSpec);
				fullSpec 	= true;
				path 		= nextPath+1;
			} else {
				AddPathComponent(path, strlen(path), fullSpec);
				fullSpec 	= true;
				break;
			}
		}
	}
	if (!fError) {
		if (!fullSpec)
			--(*this);
		if (!useAlias)
			Resolve();
	} else if (*path && fError == fnfErr) {
		fError = dirNFErr;
	}
}
@

First, we test whether the path represents an encoded [FSSpec]]. This is potentially
ambiguous, but no sane person would start a disk name with DC1. The [[ReadHex]] function,
which only works on big endian machines, reads a specified number of hex digits.
<<Auxiliary functions for class [[GUSIFileSpec]]>>=
bool ReadHex(const char * path, int bytes, char * result) 
{
	char hexbyte[3];
	hexbyte[2] = 0;
	while (bytes--) {
		hexbyte[0] = *path++; hexbyte[1] = *path++;
		if (isxdigit(hexbyte[0]) && isxdigit(hexbyte[1]))
			*result++ = (char) strtol(hexbyte, nil, 16);
		else
			return false;
	}
	return true;
}
<<Try decoding the path as an encoded [[FSSpec]]>>=
if (*path == 0x11 && path[13] == ':')			// Magic DC1 character
	if (
		!ReadHex(path+1, 2, (char *)&fSpec.vRefNum) || !ReadHex(path+5, 4, (char *)&fSpec.parID)
	) {
		fSpec.vRefNum = 0;
		fSpec.parID   = 0;
	} else
		path += 13;
@

<<Try converting the path with [[FSMakeFSSpec]] and [[return]]>>=
if (!fSpec.vRefNum && !fSpec.parID)
	GetDefaultDirectory();
int 		pathLen = (int)strlen(path);
StringPtr	ppath  	= PScratch();
if (pathLen < 256 && ppath) {
	memcpy(ppath+1, path, ppath[0] = pathLen);
	
	short 	saveVRefNum	=	fSpec.vRefNum;
	long	saveParID	=	fSpec.parID;
	
	switch (fError = FSMakeFSSpec(fSpec.vRefNum, fSpec.parID, ppath, &fSpec)) {
	case fnfErr:
		fError = noErr;
		
		return;
	case noErr:
		if (!useAlias)
			Resolve();

		while ((nextPath = strchr(path, ':')) && nextPath[1])
			path = nextPath+1;
		memcpy(ppath+1, path, ppath[0] = strlen(path) - (nextPath != 0));
		if (EqualString(fSpec.name, ppath, false, true))
			memcpy(fSpec.name, ppath, ppath[0]+1);		
		
		return;
	default:
		fSpec.vRefNum	=	saveVRefNum;
		fSpec.parID		= 	saveParID;
		break;
	}
}
@

For relative paths, we now skip a leading colon. For absolute paths, we get 
the volume information. [[fullSpec]] is true for absolute paths, but not for 
relative paths. 
<<Determine the starting directory of the path>>=
if (path[0] == ':') {
	++path;
} else if (nextPath = strchr(path, ':')) {
	if (nextPath - (char *) path > 62) {
		fError = bdNamErr;
		
		return;
	}

	memcpy(fSpec.name+1, (char *) path, fSpec.name[0] = nextPath - path);
		
	if (GetVolume())
		return;
	
	path 		= nextPath + 1;
	fullSpec	= true;
}
@

Going upwards is a bit more complicated than might seem necessary at first, because
if [["a:b"]] is an alias pointing to [["c:d:e:"]], we want a:b::"]] to be the same as 
[["c:d:"]].
<<Walk directories upwards>>=
if (!fullSpec)
	--(*this);
if (!fError)
	Resolve();
fullSpec = false;
while (!fError && *++path == ':')
	--(*this);
@

<<Inline member functions for class [[GUSIFileSpec]]>>=
inline OSErr GUSIFileSpec::SetDefaultDirectory()
{
	return fError = HSetVol(nil, fSpec.vRefNum, fSpec.parID);
}

inline OSErr GUSIFileSpec::GetDefaultDirectory()
{
	fSpec.name[0] 	= 0;
	fValidInfo		= false;
	return fError 	= HGetVol(nil, &fSpec.vRefNum, &fSpec.parID);
}
@

If [[name]] is used, we have to make sure that it ends with a colon.
<<Member functions for class [[GUSIFileSpec]]>>=
OSErr GUSIFileSpec::GetVolume(short index)
{
	fValidInfo	=	false;
	if (fSpec.name[0] || index>=0) {
		GUSIIOPBWrapper<ParamBlockRec>	vol;
		
		vol->volumeParam.ioVRefNum	=	fSpec.vRefNum;
		vol->volumeParam.ioNamePtr	=	fSpec.name;
		vol->volumeParam.ioVolIndex	=	index;
		
		if (index < 0 && fSpec.name[fSpec.name[0]] != ':')
			fSpec.name[++fSpec.name[0]] = ':';
	
		if (fError = GUSIFSGetVInfo(&vol))
			return fError;
		
		fSpec.vRefNum	=	vol->volumeParam.ioVRefNum;
	} else {
		fError 			= 	noErr;
		fSpec.vRefNum	= 	0;
	}
	fSpec.parID			=	fsRtParID;
	
	return fError;
}
@

For convenience, we define a fictivous parent directory of all volumes.
<<Privatissima of [[GUSIFileSpec]]>>=
enum { ROOT_MAGIC_COOKIE = 666 };
@

[[operator--]] replaces file specifications with their parent directory, volumes with
the root pseudo directory.
<<Member functions for class [[GUSIFileSpec]]>>=
GUSIFileSpec & GUSIFileSpec::operator--()
{
	if (fSpec.parID == fsRtParID) {
		fSpec.vRefNum 	= ROOT_MAGIC_COOKIE;
		fSpec.parID   	= 0;
		fSpec.name[0] 	= 0;
		fError			= noErr;
		fValidInfo		= false;
	} else 
		DirInfo();
	
	return *this;
}
@

[[operator++]] walks down one path component.
<<Member functions for class [[GUSIFileSpec]]>>=
GUSIFileSpec & GUSIFileSpec::operator++()
{
	if (!fSpec.parID && fSpec.vRefNum == ROOT_MAGIC_COOKIE) {
		fSpec.vRefNum	=	0;
		fSpec.parID		=	fsRtParID;
		fSpec.name[0]	=	0;
		fValidInfo		= 	false;
		
		goto punt;
	} 
			
   	if (!CatInfo())
		goto punt;
	if (fInfo->IsAlias())
		if (Resolve() || !CatInfo())
			goto punt;
	if (fInfo->IsFile()) {
		fError = afpObjectTypeErr;
		
		goto punt;
	}
	
	fSpec.parID		= fInfo->DirInfo().ioDrDirID;
	fSpec.name[0] 	= 0;
	fValidInfo		= false;

punt:	
	return *this;
}
@

[AddPathComponent]] is the basic operation for descending a directory hierarchy.
<<Member functions for class [[GUSIFileSpec]]>>=
GUSIFileSpec & GUSIFileSpec::AddPathComponent(const char * name, int length, bool fullSpec)
{
	if (length > 63) {
		fError = bdNamErr;
		
		goto punt;
	}

	if (fullSpec) 
		if (!++(*this))
			goto punt;
	
	memcpy(fSpec.name+1, name, fSpec.name[0] = length);
	fValidInfo = false;
		
	if (fSpec.parID == fsRtParID)
		GetVolume();

punt:	
	return *this;
}
@

[[operator+=]] and [[operator+]] are merely wrappers around [[AddPathComponent]].
<<Inline member functions for class [[GUSIFileSpec]]>>=
inline GUSIFileSpec &	GUSIFileSpec::operator+=(ConstStr31Param name)
{
	return AddPathComponent((char *) name+1, name[0], true);
}

inline GUSIFileSpec &	GUSIFileSpec::operator+=(const char * name)
{
	return AddPathComponent(name, strlen(name), true);
}
<<Member functions for class [[GUSIFileSpec]]>>=
GUSIFileSpec operator+(const FSSpec & spec, ConstStr31Param name)
{
	GUSIFileSpec	s(spec);
	
	return s += name;
}

GUSIFileSpec operator+(const FSSpec & spec, const char * name)
{
	GUSIFileSpec	s(spec);
	
	return s += name;
}
@

<<Member functions for class [[GUSIFileSpec]]>>=
GUSIFileSpec & GUSIFileSpec::operator[](short index)
{
	if (fSpec.parID == fsRtParID) 
		GetVolume(index);
	else 
		CatInfo(index);
	
	return *this;
}
@

<<Member functions for class [[GUSIFileSpec]]>>=
void GUSIFileSpec::SetVRef(short vref)
{
	fSpec.vRefNum 	= vref;
	fValidInfo		= false;
}

void GUSIFileSpec::SetParID(long parid)
{
	fSpec.parID	 	= parid;
	fValidInfo		= false;
}

void GUSIFileSpec::SetName(ConstStr63Param name)
{
	PLstrcpy(fSpec.name, name);
	fValidInfo	= false;
}

void GUSIFileSpec::SetName(const char * name)
{
	memcpy(fSpec.name+1, name, fSpec.name[0] = strlen(name));
	fValidInfo	= false;
}
@

<<Member functions for class [[GUSIFileSpec]]>>=
OSErr GUSIFileSpec::TouchFolder()
{
	GUSIFileSpec	folder(*this, true);
	
	if (!folder.DirInfo())
		return fError = folder.Error();
	
	GetDateTime(&folder.fInfo->DirInfo().ioDrMdDat);
	folder.fInfo->DirInfo().ioDrDirID = folder.fInfo->DirInfo().ioDrParID;
	
	return fError = GUSIFSSetCatInfo(&folder.fInfo);
}
@

The sort of information obtained depends on the [[index]] parameter.
<<Member functions for class [[GUSIFileSpec]]>>=
const GUSICatInfo * GUSIFileSpec::CatInfo(short index)
{
	if (fValidInfo && !index)	// Valid already
		return &fInfo.fPB;
		
	fInfo->DirInfo().ioVRefNum 		= fSpec.vRefNum;
	fInfo->DirInfo().ioDrDirID 		= fSpec.parID;
	fInfo->DirInfo().ioNamePtr 		= (StringPtr) fSpec.name;
	fInfo->DirInfo().ioFDirIndex 	= index;
	fInfo->DirInfo().ioACUser 		= 0;
		
	fValidInfo = !(fError = GUSIFSGetCatInfo(&fInfo)) && index>=0;
		
	return fError ? nil : &fInfo.fPB;
}
@

The other variations of the call are simple.
<<Inline member functions for class [[GUSIFileSpec]]>>=
inline const GUSICatInfo * GUSIFileSpec::CatInfo() const
{
	return const_cast<GUSIFileSpec *>(this)->CatInfo(0);
}

inline const GUSICatInfo * GUSIFileSpec::DirInfo()
{
	if (CatInfo(-1)) {
		fSpec.parID = fInfo->DirInfo().ioDrParID;
		fValidInfo	= true;
		
		return &fInfo.fPB;
	} else
		return nil;
}

inline bool GUSIFileSpec::Exists() const
{
	return CatInfo() != nil;
}

inline void GUSIFileSpec::ResetCatInfo() const
{
	GUSI_MUTABLE(GUSIFileSpec, fValidInfo) = false;
}
@

We start the path getting functions with the full path. The full and relative
path functions are quite similar, iterating a file specification [[current]] 
upward, accumulating the path in [[path]]. 
<<Member functions for class [[GUSIFileSpec]]>>=
char * GUSIFileSpec::FullPath() const
{
	char * 					path = CScratch();
	GUSIFileSpec 			current(*this);
	const GUSICatInfo * 	info 		= current.CatInfo();
	bool					directory	= info && !info->IsFile();

	if (!path) 
		return nil;
	*(path += sScratchSize-1) = 0;
	
	for (;;) {
		if (PrependPathComponent(path, current.fSpec.name, directory))
			return nil;
		directory = current.fSpec.name[0] != 0;
		if (current.fSpec.parID == fsRtParID)
			return path;
		if (!--current)
			return nil;
	}
}
@

Each accumulation step is preformed in [[PrependPathComponent]].
<<Privatissima of [[GUSIFileSpec]]>>=
OSErr PrependPathComponent(char *&path, ConstStr63Param component, bool colon) const;
<<Member functions for class [[GUSIFileSpec]]>>=
OSErr GUSIFileSpec::PrependPathComponent(char *&path, ConstStr63Param component, bool colon) const
{
	if (colon)
		*--path = ':';
	if (path-sScratch < *component+1) {
		long length = sScratch+sScratchSize-path;
		if (!CScratch(true))
			return GUSI_MUTABLE(GUSIFileSpec, fError) = -108;
		path = sScratch+sScratchSize-length;
	}
	memcpy(path -= *component, component+1, *component);
	return noErr;
}
@

[[RelativePath]] works similarly, but has to compare with the stop directory
at each step. [[GetVolume]] is called to translate all drive numbers to real
volume numbers.
<<Member functions for class [[GUSIFileSpec]]>>=
char *	GUSIFileSpec::RelativePath(const FSSpec & dir) const
{
	GUSIFileSpec current(dir);
	if (current.fSpec.name[0])
		++current;
	long	relDirID= current.fSpec.parID;
	if (current.GetVolume(0))
		return FullPath();
	short	relVRef = current.fSpec.vRefNum;
	current = *this;
	if (current.GetVolume(0) || current.fSpec.vRefNum != relVRef)
		return FullPath();

	current = *this;
		
	char * 					path 		= CScratch();
	const GUSICatInfo * 	info 		= current.CatInfo();
	bool					directory	= info && !info->IsFile();

	if (!path) 
		return nil;
	if (directory && info->DirInfo().ioDrDirID == relDirID)
		return strcpy(path, ":");
	*(path += sScratchSize-1) = 0;
	
	for (;;) {
		if (PrependPathComponent(path, current.fSpec.name, directory))
			return nil;
		if (current.fSpec.parID == relDirID) {
			if (directory)
				*--path = ':';
			return path;
		}
		directory = current.fSpec.name[0] != 0;
		if (current.fSpec.parID == fsRtParID)
			return path;
			if (!--current)
			return nil;
	}
}
@

<<Member functions for class [[GUSIFileSpec]]>>=
char *	GUSIFileSpec::RelativePath() const
{
	GUSIFileSpec	here;
	here.GetDefaultDirectory();
	return RelativePath(here);
}
@

Encoding is simple. Note the use of the [["%#s"]] Metrowerks specific extension.
<<Member functions for class [[GUSIFileSpec]]>>=
char * GUSIFileSpec::EncodedPath() const
{
	if (!CScratch())
		return nil;

	GUSI_sprintf(sScratch, "\021%04hX%08X:%#s", fSpec.vRefNum, fSpec.parID, fSpec.name);
	
	return sScratch;
}
@

<<Member functions for class [[GUSIFileSpec]]>>=
OSErr GUSIFileSpec::Resolve(bool gently)
{
	const GUSICatInfo * info = CatInfo();
	
	if (!info || (!info->IsAlias() && (fError = resFNotFound)))
		if (gently)
			return fError = noErr;
		else
			return fError;

	Boolean		isFolder;
	Boolean		wasAlias;
	
	fValidInfo	=	false;
	
	return fError = ResolveAliasFile(&fSpec, true, &isFolder, &wasAlias);
}
@

Getting the target of an alias without resolving it is quite tricky. We have to guess
whether the target is a file or a directory.
<<Member functions for class [[GUSIFileSpec]]>>=
char * GUSIFileSpec::AliasPath() const
{
	const GUSICatInfo * info = CatInfo();
	if (!info || (!info->IsAlias() && (GUSI_MUTABLE(GUSIFileSpec, fError) = resFNotFound)))
		return nil;

	char * 			path 		= CScratch();
	if (!path) 
		return nil;
	*(path += sScratchSize-1) = 0;

	AliasHandle	alias;
	<<Get the [[AliasHandle]] for the alias file and detach it>>
	bool directory;
	<<Find out if alias points at a file or a directory>>
	Str63 component;
	
	/*
		Build path from target up to root.  Separate with colons.
	*/
	for (short index = 0; 
		!(GUSI_MUTABLE(GUSIFileSpec, fError) = GetAliasInfo(alias, index, component));
		++index
	)
		if (!*component || PrependPathComponent(path, component, directory)) 
			break;
		else
			directory = true;
	
	if (!fError 
	 && !(GUSI_MUTABLE(GUSIFileSpec, fError) = GetAliasInfo(alias, asiVolumeName, component))
	)
		PrependPathComponent(path, component, true);

	DisposeHandle((Handle) alias);
	
	return fError ? nil : path;
}
@

<<Get the [[AliasHandle]] for the alias file and detach it>>=
short	oldRes	=	CurResFile();
short	res 	= 	FSpOpenResFile(&fSpec, fsRdPerm);
if (res == -1) {
	GUSI_MUTABLE(GUSIFileSpec, fError) 	= 	ResError();
	alias	=	nil;
} else {
	if (alias = (AliasHandle) Get1Resource('alis', 0))
		DetachResource((Handle) alias);
	else
		GUSI_MUTABLE(GUSIFileSpec, fError) = ResError();
	
	CloseResFile(res);
}
UseResFile(oldRes);

if (!alias)
	return nil;
@

We have to guess whether the alias points at a file or a directory, but if the alias
was constructed by GUSI or by the Finder, this guess should be correct (though not
necessarily up to date).
<<Find out if alias points at a file or a directory>>=
directory = false;
if (info->FInfo().fdCreator == 'MACS') 
	switch (info->FInfo().fdType) {
	case 'srvr':
	case 'fadr':
	case 'faet':
	case 'hdsk':
	case 'famn':
	case 'fash':
	case 'fdrp':
		directory = true;
	}
@

Comparisons are again a bit tricky because of the volume numbers.
<<Member functions for class [[GUSIFileSpec]]>>=
bool operator==(const GUSIFileSpec & one, const GUSIFileSpec & other)
{
	if (one.fSpec.parID != other.fSpec.parID || !EqualString(one.fSpec.name, other.fSpec.name, false, true))
		return false;
	if (one.fSpec.vRefNum == other.fSpec.vRefNum)
		return true;
	GUSIFileSpec current;
	current = one;
	current.GetVolume(0);
	short vRef1 = current.fSpec.vRefNum;
	current = other;
	current.GetVolume(0);
	short vRef2 = current.fSpec.vRefNum;
	
	return vRef1 == vRef2;
}
@

<<Member functions for class [[GUSIFileSpec]]>>=
bool	GUSIFileSpec::IsParentOf(const GUSIFileSpec & other) const
{
	for (GUSIFileSpec current(other); !(--current).Error();)
		if (current == *this)
			return true;
	
	return false;
}
@

Reference conversion is straightforward, as is [[operator->]].
<<Inline member functions for class [[GUSIFileSpec]]>>=
inline GUSIFileSpec::operator const FSSpec &() const
{
	return fSpec;
}
inline const FSSpec * GUSIFileSpec::operator->() const
{
	return &fSpec;
}
@

Pointers, however, are a trickier issue, as they might be used either as a 
[[GUSIFileSpec *]] or as an [[FSSpec *]].
<<Inline member functions for class [[GUSIFileSpec]]>>=
inline GUSIFileSpec::const_pointer::const_pointer(const GUSIFileSpec * ptr)
	: ptr(ptr)
{
}
inline GUSIFileSpec::const_pointer::operator const GUSIFileSpec *() const
{
	return ptr;
}
inline GUSIFileSpec::const_pointer::operator const FSSpec *() const
{
	return &ptr->fSpec;
}
inline GUSIFileSpec::const_pointer GUSIFileSpec::operator&() const
{
	return const_pointer(this);
}
@
[[GUSIFileSpec::pointer]] is the non-constant equivalent to [[GUSIFileSpec::const_pointer]].
<<Inline member functions for class [[GUSIFileSpec]]>>=
inline GUSIFileSpec::pointer::pointer(GUSIFileSpec * ptr)
	: ptr(ptr)
{
}
inline GUSIFileSpec::pointer::operator GUSIFileSpec *() const
{
	return ptr;
}
inline GUSIFileSpec::pointer::operator const FSSpec *() const
{
	return &ptr->fSpec;
}
inline GUSIFileSpec::pointer GUSIFileSpec::operator&()
{
	return pointer(this);
}
@

The constructors for [[GUSITempFileSpec]] differ in the base 
constructors they call.
<<Member functions for class [[GUSIFileSpec]]>>=
GUSITempFileSpec::GUSITempFileSpec(short vRefNum)
 : GUSIFileSpec(kTemporaryFolderType, vRefNum)
{
	TempName();
}
GUSITempFileSpec::GUSITempFileSpec(short vRefNum, long parID)
{
	SetVRef(vRefNum);
	SetParID(parID);
	
	TempName();
}
@

Optionally, a base name can be specified for a temporary name.
<<Member functions for class [[GUSIFileSpec]]>>=
GUSITempFileSpec::GUSITempFileSpec(ConstStr63Param basename)
 : GUSIFileSpec(kTemporaryFolderType, kOnSystemDisk)
{
	TempName(basename);
}
GUSITempFileSpec::GUSITempFileSpec(short vRefNum, ConstStr31Param basename)
 : GUSIFileSpec(kTemporaryFolderType, vRefNum)
{
	TempName(basename);
}
GUSITempFileSpec::GUSITempFileSpec(short vRefNum, long parID, ConstStr31Param basename)
{
	SetVRef(vRefNum);
	SetParID(parID);
	
	TempName(basename);
}
@

The names are searched by [[TempName]]. To avoid excessive searching, each 
search starts at a new location.
<<Member functions for class [[GUSIFileSpec]]>>=
int GUSITempFileSpec::sID = 0;

void GUSITempFileSpec::TempName()
{
	for (;;) {
		char	name[8];

		GUSI_sprintf(name, "tmp%04d", sID++);		
		SetName(name);
		
		sID 		%= 10000;
		fValidInfo   = false;
		if (!Exists()) {
			if (fError == fnfErr)
				fError = noErr;
			return;
		}
	}
}
@

The search with an existing base name is a slight variation on the above.
<<Member functions for class [[GUSIFileSpec]]>>=
void GUSITempFileSpec::TempName(ConstStr31Param basename)
{
	for (int id = 0;;++id) {
		Str32	name;
		int 	len = 2;

		if (id < 10)
			;
		else if (id < 100)
			len = 3;
		else if (id < 1000)
			len = 4;
		else if (id < 10000)
			len = 5;
		else {
			fError = fnfErr;
			return;
		}
		
		<<Insert [[id]] at the appropriate place into [[basename]]>>
		SetName(name);
		
		fValidInfo   = false;
		if (!Exists()) {
			if (fError == fnfErr)
				fError = noErr;
			return;
		}
	}
}
@

I think it looks a bit prettier if the number is stuck before the first dot, instead of at the end.
<<Insert [[id]] at the appropriate place into [[basename]]>>=
if (!id) {
	memcpy(name, basename, *basename+1);
} else if (*basename + len > 31) {
	name[0] = 30;
	memcpy(name+1, basename+1, 31-len);
	GUSI_sprintf(reinterpret_cast<char *>(name+32-len), "%d", id);
} else {
	name[0] = *basename + len;
	unsigned char * period = reinterpret_cast<unsigned char *>(memchr(basename+1, '.', *basename));
	int prelen = period ? (period-basename)-1 : *basename;
	memcpy(name+1, basename+1, prelen);
	GUSI_sprintf(reinterpret_cast<char *>(name+1+prelen), ".%d", id);
	memcpy(name+1+prelen+len, period, *basename-prelen);
}
@

\section{Implementation of C APIs to [[GUSIFileSpec]]}

The C API is fairly easy to implement. We move the common parts of the [[FSSpec]] constructors
into an auxiliary procedure.
<<C API functions for [[GUSIFileSpec]]>>=
static OSErr GUSIFileSpec2FSp(const GUSIFileSpec & spec, FSSpec * desc)
{
	if (!spec.Error())
		*desc = spec;
	
	return spec.Error();
}
@

The constructors now turn into one liners.
<<C API functions for [[GUSIFileSpec]]>>=
OSErr GUSIFRefNum2FSp(short fRefNum, FSSpec * desc)	
	{ return GUSIFileSpec2FSp(GUSIFileSpec(fRefNum), desc); 		}
OSErr GUSIWD2FSp(short wd, ConstStr31Param name, FSSpec * desc)
	{ return GUSIFileSpec2FSp(GUSIFileSpec(wd, name, true), desc); 	}
OSErr GUSIPath2FSp(const char * path, FSSpec * desc)
	{ return GUSIFileSpec2FSp(GUSIFileSpec(path, true), desc); 		}
OSErr GUSISpecial2FSp(OSType object, short vol, FSSpec * desc)
	{ return GUSIFileSpec2FSp(GUSIFileSpec(object, vol), desc); 	}
@

The temporary constructor is only a little bit trickier.
<<C API functions for [[GUSIFileSpec]]>>=
OSErr GUSIMakeTempFSp(short vol, long dirID, FSSpec * desc)
	{ return GUSIFileSpec2FSp((dirID ? GUSITempFileSpec(vol, dirID) : GUSITempFileSpec(vol)), desc); 		} 
@

The manipulators look a bit like constructors.

<<C API functions for [[GUSIFileSpec]]>>=
OSErr GUSIFSpUp(FSSpec * desc)
	{ return GUSIFileSpec2FSp(--GUSIFileSpec(*desc, true), desc); 			}
OSErr GUSIFSpDown(FSSpec * desc, ConstStr31Param name)
	{ return GUSIFileSpec2FSp(*desc+name, desc); 							}			
OSErr GUSIFSpIndex(FSSpec * desc, short n)
	{ GUSIFileSpec spec(*desc);  return GUSIFileSpec2FSp(spec[n], desc);	}
OSErr GUSIFSpResolve(FSSpec * desc)
	{ return GUSIFileSpec2FSp(GUSIFileSpec(*desc), desc); 					}
@

The deconstructors are two liners anyway.
<<C API functions for [[GUSIFileSpec]]>>=
char * GUSIFSp2FullPath(const FSSpec * desc)
{
	GUSIFileSpec spec(*desc, true);
	
	return spec.FullPath();
}

char * GUSIFSp2RelPath(const FSSpec * desc)
{
	GUSIFileSpec spec(*desc, true);
	
	return spec.RelativePath();
}

char * GUSIFSp2DirRelPath(const FSSpec * desc, const FSSpec * dir)
{
	GUSIFileSpec spec(*desc, true);
	
	return spec.RelativePath(*dir);
}

char * GUSIFSp2Encoding(const FSSpec * desc)
{
	GUSIFileSpec spec(*desc, true);
	
	return spec.EncodedPath();
}
@


<<C API functions for [[GUSIFileSpec]]>>=
OSErr GUSIFSpTouchFolder(const FSSpec * desc)
{
	GUSIFileSpec spec(*desc);
	
	return spec.TouchFolder();
}

OSErr GUSIFSpGetCatInfo(FSSpec * desc, CInfoPBRec * info)
{
	GUSIFileSpec 		spec(*desc);
	const GUSICatInfo *	gci = spec.CatInfo();
	
	if (gci) {
		*info						= gci->Info();
		*desc 						= spec;
		info->hFileInfo.ioNamePtr 	= desc->name;
	}
		
	return spec.Error();
}
@
