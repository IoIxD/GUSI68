%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Project	:	GUSI				-	Grand Unified Socket Interface
% File		:	GUSIContext.nw		-	Thread and Process structures
% Author	:	Matthias Neeracher
% Language	:	C++
% 
% $Log: GUSIContext.nw,v $
% Revision 1.26  2002/11/19 07:03:47  neeri
% Kill GUSIProcess instance before GUSIContexts
%
% Revision 1.25  2002/09/03 05:13:56  neeri
% Reengineered signal handling to properly handle handlers that longjmp() [GUSI Bug #564063]
%
% Revision 1.24  2002/01/07 05:56:20  neeri
% Compatibility fixes for CodeWarrior Pro 7
%
% Revision 1.23  2001/03/09 09:26:05  neeri
% Tweaks for Natty support
%
% Revision 1.22  2001/01/22 04:31:11  neeri
% Last minute changes for 2.1.5
%
% Revision 1.21  2001/01/17 08:43:42  neeri
% Tweak scheduling
%
% Revision 1.20  2000/12/23 06:09:21  neeri
% May need to create context for IO completions
%
% Revision 1.19  2000/10/16 04:34:22  neeri
% Releasing 2.1.2
%
% Revision 1.18  2000/06/01 06:31:09  neeri
% Delete SigContext
%
% Revision 1.17  2000/05/23 06:56:19  neeri
% Improve formatting, add socket closing queue, tune scheduling
%
% Revision 1.16  2000/03/15 07:11:50  neeri
% Fix detached delete (again), switcher restore
%
% Revision 1.15  2000/03/06 08:10:09  neeri
% Fix sleep in main thread
%
% Revision 1.14  2000/03/06 06:13:46  neeri
% Speed up thread/process switching through minimal quotas
%
% Revision 1.13  1999/12/13 02:40:50  neeri
% GUSISetThreadSwitcher had Boolean <-> bool inconsistency
%
% Revision 1.12  1999/11/15 07:25:32  neeri
% Safe context setup. Check interrupts only in foreground.
%
% Revision 1.11  1999/09/09 07:18:06  neeri
% Added support for foreign threads
%
% Revision 1.10  1999/08/26 05:44:59  neeri
% Fixes for literate edition of source code
%
% Revision 1.9  1999/06/28 05:59:02  neeri
% Add signal handling support
%
% Revision 1.8  1999/05/30 03:09:29  neeri
% Added support for MPW compilers
%
% Revision 1.7  1999/03/17 09:05:05  neeri
% Added GUSITimer, expanded docs
%
% Revision 1.6  1999/02/25 03:34:24  neeri
% Introduced GUSIContextFactory, simplified wakeup
%
% Revision 1.5  1998/11/22 23:06:51  neeri
% Releasing 2.0a4 in a hurry
%
% Revision 1.4  1998/10/11 16:45:11  neeri
% Ready to release 2.0a2
%
% Revision 1.3  1998/08/01 21:26:18  neeri
% Switch dynamically to threading model
%
% Revision 1.2  1998/02/11 12:57:11  neeri
% PowerPC Build
%
% Revision 1.1  1998/01/25 21:02:41  neeri
% Engine implemented, except for signals & scheduling
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Thread and Process structures}

This section defines the process and thread switching engine of GUSI.

In some execution environments, completion routines execute at interrupt level.
GUSI therefore is designed so all information needed to operate from interrupt
level is accessible from a [[GUSISocket]]. This information is separated into
per-process data, collected in [[GUSIProcess]], and per-thread data, collected 
in [[GUSIContext]]. [[GUSIProcess]] is always a singleton, while [[GUSIContext]]
is a singleton if threading is disabled, and has multiple instances if threading
is enabled. By delegating the [[GUSIContext]] creation process to an instance
of a [[GUSIContextFactory]], we gain some extra flexibility.

As soon as GUSI has started an asynchronous call, it calls the [[Wait]] member
function of its context. [[msec]] will set a time limit after which the call will 
return in any case. Exceptional events may also cause [[GUSIWait]] to return, so 
it is not safe to assume that the call will have completed upon return.

<<GUSIContext.h>>=
#ifndef _GUSIContext_
#define _GUSIContext_

#include <errno.h>
#include <sys/cdefs.h>
#include <sys/signal.h>

#include <MacTypes.h>
#include <Threads.h>

__BEGIN_DECLS
<<Definition of thread manager hooks>> 
__END_DECLS

#ifndef GUSI_SOURCE

typedef struct GUSIContext GUSIContext;

#else

#include "GUSISpecific.h"
#include "GUSIBasics.h"
#include "GUSIContextQueue.h"

#include <Files.h>
#include <Processes.h>
#include <OSUtils.h>

<<Name dropping for file GUSIContext>>

#include <ConditionalMacros.h>

#if PRAGMA_STRUCT_ALIGN
#pragma options align=native
#endif

<<Definition of class [[GUSIThreadManagerProxy]]>>
<<Definition of class [[GUSIProcess]]>>
<<Definition of class [[GUSIContext]]>>
<<Definition of class [[GUSIContextFactory]]>>
<<Definition of IO wrappers>>

#if PRAGMA_STRUCT_ALIGN
#pragma options align=reset
#endif

<<Inline member functions for file GUSIContext>>

#endif /* GUSI_SOURCE */

#endif /* _GUSIContext_ */
@

<<GUSIContext.cp>>=
#include "GUSIInternal.h"
#include "GUSIContext.h"
#include "GUSIDiag.h"
#include "GUSISignal.h"
#include "GUSIConfig.h"
#include "GUSIDescriptor.h"
#include "GUSITimer.h"

#include <errno.h>
#include <signal.h>

#include <EPPC.h>
#include <LowMem.h>
#include <AppleEvents.h>
#include <Quickdraw.h>
#include <Devices.h>

#include <utility>
#include <memory>

GUSI_USING_STD_NAMESPACE

<<Implementation of completion handling>>
@


\section{Definition of completion handling}

{\tt GUSIContext} is heavily circular both with classes declared herein and
in other files. Therefore, we start by declaring a few class names.
<<Name dropping for file GUSIContext>>=
class GUSISocket;
class GUSIContext;
class GUSIProcess;
class GUSISigProcess;
class GUSISigContext;
class GUSITimer;
@ 

A [[GUSIProcess]] contains all the data needed to wake up a process:

\begin{itemize}
\item The [[ProcessSerialNumber]] of the process.
\item The [[ThreadTaskRef]] if threads are enabled.
\item The contents of the A5 register.
\end{itemize}

The sole instance of [[GUSIProcess]] is obtained by calling the [[GUSIProcess::Instance]] static member
function, which will create the instance if necessary. Interrupt level prcedures may access the application's 
A5 register either manually by calling [[GetA5]] or simply by declaring a [[GUSIProcess::A5Saver]] in a scope.
<<Definition of class [[GUSIProcess]]>>=
enum GUSIYieldMode {
	kGUSIPoll,		// Busy wait for some unblockable condition
	kGUSIBlock,		// Wait for some blockable condition
	kGUSIYield		// Yield to some other eligible thread
};

class GUSIProcess {
public:
	static GUSIProcess *	Instance();
	static void				DeleteInstance();
	void					GetPSN(ProcessSerialNumber * psn);
	void					AcquireTaskRef();
	ThreadTaskRef			GetTaskRef();
	long					GetA5();
	bool					Threading();
	void					Yield(GUSIYieldMode wait);
	void					Wakeup();
	GUSISigProcess *		SigProcess() { return fSigProcess; }
	void					QueueForClose(GUSISocket * sock);
	<<Definition of class [[GUSIProcess::A5Saver]]>>
protected:
	friend class GUSIContext;
	
	GUSIProcess(bool threading);
	~GUSIProcess();
	
	int						fReadyThreads;
	int						fExistingThreads;
	GUSISigProcess *		fSigProcess;
private:
	<<Privatissima of [[GUSIProcess]]>>
};
@ %def GUSIProcess

A [[GUSIProcess::A5Saver]] is a class designed to restore the process A5 
register for the scope of its declaration. 
<<Definition of class [[GUSIProcess::A5Saver]]>>=
class A5Saver {
public:
	A5Saver(long processA5);
	A5Saver(GUSIContext * context);
	A5Saver(GUSIProcess * process);
	~A5Saver();
private:
	long	fSavedA5;
};
@ %def GUSIProcess::A5Saver

A [[GUSIContext]] gathers thread related data. The central operation on a 
[[GUSIContext]] is [[Wakeup]]. If the process is not asleep when [[Wakeup]] 
is called, it is marked for deferred wakeup. 

A [[GUSIContext]] can either be created from an existing thread manager
[[ThreadID]] or by specifying the parameters for a [[NewThread]] call.

[[Current]] returns the current [[GUSIContext]]. [[Setup]] initializes the
default context for either the threading or the non-threading model. 

[[Yield]] suspends the current process or thread until something interesting
happens if [[wait]] is [[kGUSIBlock]. Otherwise, [[Yield]] switches,
but does not suspend. For an ordinary thread context, [[Yield]] simply yields 
the thread. For the context in a non-threading application, [[Yield]] does a 
[[WaitNextEvent]]. For the main thread context, [[Yield]] does both.

[[Done]] tests whether the thread has terminated yet. If [[join]] is set,
the caller is willing to wait. [[Result]] returns the default location to store 
the thread result if no other is specified. 

By default, a context is joinable. Calling [[Detach]] will cause the context to
be destroyed automatically upon thread termination, and joins are no longer allowed.
A joinable context will not be destroyed automatically before the end of the 
program, so you will have to call [[Liquidate]] to do that.

[[SetSwitchIn]], [[SetSwitchOut]], and [[SetTerminator]] set per-thread user
switch and termination procedures. [[SwitchIn]], [[SwitchOut]], and [[Terminate]]
call the user defined procedures then perform their own actions.
<<Definition of class [[GUSIContext]]>>=
class GUSIContext : public GUSISpecificTable {
public:
	friend class GUSIProcess;
	friend class GUSIContextFactory;
	
	ThreadID				ID()			{	return fThreadID;			}
	virtual void 			Wakeup();
	void					ClearWakeups()	{ fWakeup = false; 			}
	GUSIProcess *			Process()		{	return fProcess;			}
	void 					Detach()		{	fFlags |= detached;			}
	void 					Liquidate();
	OSErr					Error()			{ 	return sError;				}
	bool					Done(bool join);
	void *					Result()		{   return fResult;				}
	GUSISigContext *		SigContext()	{ 	return fSigContext;			}

	static GUSIContext *	Current()		{	return sCurrentContext;		}
	static GUSIContext *	CreateCurrent(bool threading = false)	
		{	if (!sCurrentContext) Setup(threading);	return sCurrentContext;	}
	static GUSIContext *	Lookup(ThreadID id);
	static void				Setup(bool threading);
	static bool				Yield(GUSIYieldMode wait);
	static void				SigWait(sigset_t sigs);
	static void				SigSuspend();
	static void				Raise();
	static bool				Interrupt(bool allSigs = false);
	static sigset_t			Pending();
	static sigset_t			Blocked();
	
	void SetSwitchIn(ThreadSwitchProcPtr switcher, void *switchParam);
	void SetSwitchOut(ThreadSwitchProcPtr switcher, void *switchParam);
	void SetTerminator(ThreadTerminationProcPtr terminator, void *terminationParam);	
	
	static GUSIContextQueue::iterator	begin()	{	return sContexts.begin();	}
	static GUSIContextQueue::iterator	end()	{	return sContexts.end();		}
	static void	LiquidateAll()					{ 	sContexts.LiquidateAll(); 	}
protected:
	<<Friends of [[GUSIContext]]>>

	GUSIContext(ThreadID id);	
	GUSIContext(
		ThreadEntryProcPtr threadEntry, void *threadParam, 
		Size stackSize, ThreadOptions options, void **threadResult, ThreadID *threadMade);

	virtual void SwitchIn();
	virtual void SwitchOut();
	virtual void Terminate();
	
	<<Privatissima of [[GUSIContext]]>>
};
@ %def GUSIContext

[[GUSIContext]] instances are created by instances of [[GUSIContextFactory]].
<<Definition of class [[GUSIContextFactory]]>>=
class GUSIContextFactory {
public:
	static GUSIContextFactory *	Instance();
	static void 				SetInstance(GUSIContextFactory * instance);
	static void 				DeleteInstance();
	
	virtual GUSIContext	* CreateContext(ThreadID id);
	virtual GUSIContext * CreateContext(
		ThreadEntryProcPtr threadEntry, void *threadParam, 
		Size stackSize, ThreadOptions options = kCreateIfNeeded, 
		void **threadResult = nil, ThreadID *threadMade = nil);

	virtual ~GUSIContextFactory();
protected:
	GUSIContextFactory();
};
@ %def GUSIContextFactory

To maintain correct state, we have to remain informed which thread is active, so
we install all sorts of hooks. Clients have to use the C++ interface or call
[[GUSINewThread]], [[GUSISetThreadSwitcher]], and [[GUSISetThreadTerminator]].
instead of the thread manager routines.
<<Definition of thread manager hooks>>=
OSErr GUSINewThread(
		ThreadStyle threadStyle, ThreadEntryProcPtr threadEntry, void *threadParam, 
		Size stackSize, ThreadOptions options, 
		void **threadResult, ThreadID *threadMade);
OSErr GUSISetThreadSwitcher(ThreadID thread, 
		ThreadSwitchProcPtr threadSwitcher, void *switchProcParam, Boolean inOrOut);
OSErr GUSISetThreadTerminator(ThreadID thread, 
		ThreadTerminationProcPtr threadTerminator, void *terminationProcParam);
@ %def GUSINewThread GUSISetThreadSwitcher GUSISetThreadTerminator

Many asynchronous calls take the same style of I/O parameter block and thus
can be handled by the same completion procedure. [[StartIO]] prepares
a parameter block for asynchronous I/O; [[FinishIO]] waits for the I/O
to complete. The parameter block has to be wrapped in a [[GUSIIOPBWrapper]].
<<Definition of IO wrappers>>=
void GUSIStartIO(ParamBlockRec * pb);
OSErr GUSIFinishIO(ParamBlockRec * pb);
OSErr GUSIControl(ParamBlockRec * pb);
template <class PB> struct GUSIIOPBWrapper {
	GUSIContext *	fContext;
	PB				fPB;
	
	GUSIIOPBWrapper() 				{}
	GUSIIOPBWrapper(const PB & pb) 	{ memcpy(&fPB, &pb, sizeof(PB)); 			}
	
	PB * operator->(){ return &fPB;												}
	void StartIO() 	 { GUSIStartIO(reinterpret_cast<ParamBlockRec *>(&fPB));			}
	OSErr FinishIO() { return GUSIFinishIO(reinterpret_cast<ParamBlockRec *>(&fPB)); 	}
	OSErr Control()	 { return GUSIControl(reinterpret_cast<ParamBlockRec *>(&fPB));  	}
};
@ %def GUSIIOPBWrapper

Ultimately, we will call through to the thread manager, but if an application uses foreign 
sources of threads, we might have to go through indirections.
<<Definition of class [[GUSIThreadManagerProxy]]>>=
class GUSIThreadManagerProxy {
public:
	virtual OSErr NewThread(
				ThreadStyle threadStyle, ThreadEntryProcPtr threadEntry, void *threadParam, 
				Size stackSize, ThreadOptions options, void **threadResult, ThreadID *threadMade);
	virtual OSErr SetThreadSwitcher(
				ThreadID thread, ThreadSwitchProcPtr threadSwitcher, void *switchProcParam, 
				Boolean inOrOut);
	virtual OSErr SetThreadTerminator(
				ThreadID thread, ThreadTerminationProcPtr threadTerminator, void *terminatorParam);
	
	virtual ~GUSIThreadManagerProxy() {}
	
	static GUSIThreadManagerProxy * Instance();
protected:
	GUSIThreadManagerProxy()	{}
	
	static GUSIThreadManagerProxy * MakeInstance();
};
@ %def GUSIThreadManagerProxy

\section{Implementation of completion handling}

[[Instance]] returns the sole instance of [[GUSIProcess]], creating it if
necessary. 
<<Privatissima of [[GUSIProcess]]>>=
static GUSIProcess *	sInstance;
<<Implementation of completion handling>>=
GUSIProcess * GUSIProcess::sInstance;
<<Inline member functions for file GUSIContext>>=
inline GUSIProcess * GUSIProcess::Instance()
{
	if (!sInstance) 
		sInstance = new GUSIProcess(GUSIContext::sHasThreading);
	return sInstance;
}
inline void GUSIProcess::DeleteInstance()
{
	delete sInstance;
	sInstance = 0;
}
@

Much of the information stored in a [[GUSIProcess]] is static and read-only.
<<Privatissima of [[GUSIProcess]]>>=
ProcessSerialNumber	fProcess;
ThreadTaskRef		fTaskRef;
long				fA5;
@
<<Inline member functions for file GUSIContext>>=
inline void 			GUSIProcess::GetPSN(ProcessSerialNumber * psn)	
							{ *psn = fProcess;	}
inline void				GUSIProcess::AcquireTaskRef()
							{ GetThreadCurrentTaskRef(&fTaskRef); }
inline ThreadTaskRef	GUSIProcess::GetTaskRef()				
							{ return fTaskRef;	}
inline long				GUSIProcess::GetA5()								
							{ return fA5;		}
inline bool				GUSIProcess::Threading()							
							{ return fTaskRef!=0;}
@

The exception is the [[fClosing]] socket queue and some yielding related flags.
<<Privatissima of [[GUSIProcess]]>>=
GUSISocket *		fClosing;
UInt32				fResumeTicks;
bool				fWillSleep;
bool				fDontSleep;
@

<<Implementation of completion handling>>=
GUSI_NEEDS_QD

GUSIProcess::GUSIProcess(bool threading)
{
	GetCurrentProcess(&fProcess);
	fA5 = (long) LMGetCurrentA5();
	if (threading)
		AcquireTaskRef();
	else
		fTaskRef = 0;
	GUSIConfiguration::Instance()->AutoInitGraf();
	fReadyThreads 	= 0;
	fExistingThreads= 0;
	fResumeTicks  	= 0;
	fWillSleep 		= false;
	fDontSleep 		= false;
	fSigProcess		= GUSISigFactory::Instance()->CreateSigProcess();
	fClosing		= 0;
}
@

We can't do this inline as this would create a circular dependency.
<<Implementation of completion handling>>=
void GUSIProcess::QueueForClose(GUSISocket * sock)
{
	sock->Enqueue(&fClosing);
}
@

On termination of the [[GUSIProcess]], we accelerate the closings of all
pending sockets.
<<Implementation of completion handling>>=
GUSIProcess::~GUSIProcess()
{
	UInt32 	start = LMGetTicks();
	UInt32	now	  = start;
	
	while (fClosing)	{ 
		fClosing->CheckClose(now);
		if (now < start+300)	// Normal speed for 5 seconds
			now = LMGetTicks();
		else					
			now += 300;			// Accelerate
	}
}
@

An [[A5Saver]] is trivially implemented but it simplifies bookkeeping.
<<Inline member functions for file GUSIContext>>=
inline GUSIProcess::A5Saver::A5Saver(long processA5)		
	{	fSavedA5 = SetA5(processA5);					}
inline GUSIProcess::A5Saver::A5Saver(GUSIProcess * process)
	{	fSavedA5 = SetA5(process->GetA5());			}
inline GUSIProcess::A5Saver::A5Saver(GUSIContext * context)
	{	fSavedA5 = SetA5(context->Process()->GetA5());	}
inline GUSIProcess::A5Saver::~A5Saver()
	{	SetA5(fSavedA5);								}
@

[[GUSIContext::Setup]] initializes the default context. We have to employ 
[[sCreatingCurrentContext]] to avoid nasty recursions.
<<Implementation of completion handling>>=
void GUSIContext::Setup(bool threading)
{
	bool	wasThreading = sHasThreading;
	if (threading)
		sHasThreading = true;
	if (!sCurrentContext && !sCreatingCurrentContext) {
		MaxApplZone();		// It's about time, too!
		
		sCreatingCurrentContext = true;
		sCurrentContext = 
			GUSIContextFactory::Instance()->CreateContext(kApplicationThreadID);
		sCreatingCurrentContext = false;
	} else if (!wasThreading && threading) {
		<<Upgrade application context to threading>>
	}
}
@

Sometimes we only recognize that we need threading after the application context
has already been created. Assuming a disciplined use of threads, we can assume
that the current context is still the application context, so all we have to do
is to set the thread switcher for it.
<<Upgrade application context to threading>>=
GUSIThreadManagerProxy::Instance()->SetThreadSwitcher(
	kApplicationThreadID, (ThreadSwitchProcPtr)GUSIThreadSwitchIn, sCurrentContext, true);
GUSIThreadManagerProxy::Instance()->SetThreadSwitcher(
	kApplicationThreadID, (ThreadSwitchProcPtr)GUSIThreadSwitchOut, sCurrentContext, false);
GUSIProcess::Instance()->AcquireTaskRef();
@

At this point, we need to introduce all the private data of a [[GUSIContext]].

\begin{itemize}
\item [[fThreadID]] stores the thread manager thread ID. 
\item [[fProcess]] keeps a pointer to the process structure, so completion 
routines can get at it. 
\item [[sCurrentContext]] always points at the current context.
\item [[sContexts]] contains a queue of all contexts.
\item [[sHasThreads]] reminds us whether we are threading or not.
\item We define our own switch-in and termination procedures. If the user specifies procedures 
we store them in [[fSwitchInProc]], [[fSwitchOutProc]], and [[fTerminateProc]] and their parameters 
in [[fSwitchInParam]], [[fSwitchOutParam]], and [[fTerminateParam]] so we can call through to them 
from our procedures.
\item [[fJoin]] contains the context waiting for us to die;
\item [[done]] reminds us if the thread is still alive. [[detached]] guarantees
that we will never wait for that thread anymore.
\item Last of all, we keep the global error variables [[errno]] and [[h_errno]] 
for each context in the [[fErrno]] and [[fHostErrno]] fields.
\end{itemize}

<<Privatissima of [[GUSIContext]]>>=	
ThreadID 					fThreadID;	
GUSIProcess *				fProcess;
GUSIContext *				fNext;
GUSISigContext *			fSigContext;
ThreadSwitchProcPtr			fSwitchInProc;
ThreadSwitchProcPtr			fSwitchOutProc;
ThreadTerminationProcPtr	fTerminateProc;
void *						fSwitchInParam;
void *						fSwitchOutParam;
void *						fTerminateParam;
void *						fResult;
GUSIContext *				fJoin;
enum {
	done 	= 1 << 0, 
	detached= 1 << 1,
	asleep	= 1 << 2
};
char						fFlags;
bool						fWakeup;
UInt32						fEntryTicks;
int							fErrno;
int							fHostErrno;

class Queue : public GUSIContextQueue {
public:
	void LiquidateAll();
	
	~Queue()			{ LiquidateAll(); }
};

static Queue			sContexts;
static GUSIContext *	sCurrentContext;
static bool				sCreatingCurrentContext;
static bool				sHasThreading;
static OSErr			sError;
<<Implementation of completion handling>>=
GUSIContext::Queue 		GUSIContext::sContexts;
GUSIContext * 			GUSIContext::sCurrentContext;
bool					GUSIContext::sCreatingCurrentContext;
bool					GUSIContext::sHasThreading;
OSErr					GUSIContext::sError;
@

The [[GUSIContext]] constructor links the context into the queue of existing
contexts and installs the appropriate thread hooks. We split this into two 
routines: [[StartSetup]] does static setup before the thread id is determined,
[[FinishSetup]] does the queueing.
<<Privatissima of [[GUSIContext]]>>=
void StartSetup();
void FinishSetup();
<<Implementation of completion handling>>=
extern int h_errno;

void GUSIContext::StartSetup()
{
	fSwitchInProc	=	0;
	fSwitchOutProc	=	0;
	fTerminateProc	=	0;
	fErrno			=	errno;
	fHostErrno		=	h_errno;
	fJoin			=	nil;
	fFlags			=	0;
	fWakeup			= 	false;
}

void GUSIContext::FinishSetup()
{
	fProcess		= GUSIProcess::Instance();
	fSigContext		= 
		GUSISigFactory::Instance()->CreateSigContext(
			sCurrentContext ? sCurrentContext->fSigContext : 0);
	++fProcess->fReadyThreads;
	++fProcess->fExistingThreads;
	sContexts.push(this);
	if (sHasThreading) {
		GUSIThreadManagerProxy::Instance()->SetThreadSwitcher(
			fThreadID, (ThreadSwitchProcPtr)GUSIThreadSwitchIn, this, true);
		GUSIThreadManagerProxy::Instance()->SetThreadSwitcher(
			fThreadID, (ThreadSwitchProcPtr)GUSIThreadSwitchOut, this, false);
		if (fThreadID != kApplicationThreadID)
			GUSIThreadManagerProxy::Instance()->SetThreadTerminator(
				fThreadID, (ThreadTerminationProcPtr)GUSIThreadTerminator, this);
	}
	GUSI_MESSAGE(("Create #%d\n", fThreadID));
}
@

The preexisting thread constructor is now simple to define.
<<Implementation of completion handling>>=
GUSIContext::GUSIContext(ThreadID id)
{
	StartSetup();
	fThreadID = id;
	sError	  = 0;
	FinishSetup();
}
@

And so is the creation contructor, come to think of it. 
<<Implementation of completion handling>>=
GUSIContext::GUSIContext(ThreadEntryProcPtr threadEntry, void *threadParam, 
        Size stackSize, ThreadOptions options, void ** result, ThreadID * thread)
{
    StartSetup();
	if (!result)
		result = &fResult;
    sError = GUSIThreadManagerProxy::Instance()->NewThread(
				kCooperativeThread, threadEntry, threadParam, 
        		stackSize, options, result, &fThreadID);
	if (thread)
    	*thread = fThreadID;
	if (sError)
        return;
    FinishSetup();
}
@

[[GUSIContext::Lookup]] does a linear search.
<<Implementation of completion handling>>=
GUSIContext * GUSIContext::Lookup(ThreadID id)
{
	for (GUSIContextQueue::iterator context = begin(); context != end(); ++context)
		if (context->fThreadID == id)
			return *context;
	return nil;
}
@

Destruction of a [[GUSIContext]] requires some cleanup.
<<Privatissima of [[GUSIContext]]>>=
virtual ~GUSIContext();
<<Implementation of completion handling>>=
GUSIContext::~GUSIContext()
{
	sContexts.remove(this);
	
	delete fSigContext;
}
@

Furthermore, at the end of an application, we need some global cleanup. This
is especially true for MPW tools. Furthermore, we shouldn't start throwing away
contexts before all sockets are closed. The [[GUSIProcess]] instance needs
to be killed first as well, because that can trigger closing sockets which were
still pending.
<<Implementation of completion handling>>=
void GUSIContext::Queue::LiquidateAll()
{
	GUSIContextFactory::DeleteInstance();
	GUSIDescriptorTable::CloseAllDescriptors();
	GUSIProcess::DeleteInstance();
	while (!empty())
		front()->Liquidate();
}

void GUSIContext::Liquidate()
{
	GUSI_MESSAGE4(("GUSIContext::Liquidate %08x\n", fThreadID));
	switch (fThreadID) {
	case kApplicationThreadID:	// Main thread, restore switchers
		if (sHasThreading) {
			SetThreadSwitcher(fThreadID, fSwitchInProc,  fSwitchInParam,  true);
			SetThreadSwitcher(fThreadID, fSwitchOutProc, fSwitchOutParam, false);
		}
		break;
	default:					// Other thread, terminate
		if (!(fFlags & done)) {
			fFlags &= ~detached;	// Will destroy context ourselves
			DisposeThread(fThreadID, nil, false);
		}
		break;
	}
	delete this;
}
@

[[GUSIContext::Wakeup]] awakens a context. In every asynchronous call, there 
is a risk of race conditions, i.e., the call completes before the 
thread/process making it goes to sleep. For threads, we can handle this case 
by checking for a wakeup in the switch out procedure (an idea due to Quinn). 
<<Implementation of completion handling>>=
void GUSIContext::Wakeup()
{
	if (fWakeup) {
		GUSI_MESSAGE(("Duplicate wakeup #%d\n", fThreadID));
	} else {
		GUSI_MESSAGE(("Wakeup #%d\n", fThreadID));
		fWakeup = true;
		if (fThreadID && fThreadID != kApplicationThreadID)
			SetThreadReadyGivenTaskRef(Process()->GetTaskRef(), fThreadID);
		Process()->Wakeup();
	}
}
@ 

The code for processes used to be quite complex. However, it turned out that there are
in fact no race cvonditions with [[WaitNextEvent]] and it was my attempted countermeasures
which caused trouble instead. Thanks to Keith Stattenfield for finally setting me straight.

\begin{itemize}
\item If [[fDontSleep]] is set, the process will not go to sleep in the first place (presumably because
	a wakeup is already pending).
\item Otherwise, if [[fWillSleep]] is not set, we can prevent the process from going to sleep by setting 
	[[fDontSleep]].
\item Otherwise, we can wake it up by calling [[WakeUpProcess]], whether or not [[WaitNextEvent]]
	has already been called.
\end{itemize}

<<Implementation of completion handling>>=
void GUSIProcess::Wakeup()
{
	if (fDontSleep) {
		GUSI_SMESSAGE("Duplicate WakeUpProcess\n");
	} else {
		fDontSleep 			= true;
		
		if (!fWillSleep) {
			GUSI_SMESSAGE("Caught sleep in time\n");
		} else {		
			GUSI_SMESSAGE("WakeUpProcess\n");
			
			WakeUpProcess(&fProcess);
		}
	}
}
@

The thread wrappers are fairly trivial.
<<Implementation of completion handling>>=
OSErr GUSINewThread(
	ThreadStyle, ThreadEntryProcPtr threadEntry, void *threadParam, 
	Size stackSize, ThreadOptions options, void **threadResult, ThreadID *threadMade)
{
	GUSIContext * context = GUSIContextFactory::Instance()->CreateContext(
				threadEntry, threadParam, stackSize, options, 
				threadResult, threadMade);
	OSErr err = context->Error();
	if (err)
		context->Liquidate();
	return err;
}
@

To make it possible to install an alternative [[GUSIContextFactory]], we provide the
[[GUSISetupContextFactory()]] hook for overriding;
<<Definition of class [[GUSIContextFactory]]>>=
extern "C" void GUSISetupContextFactory();
<<Implementation of completion handling>>=
#ifdef __MRC__
#pragma noinline_func GUSISetupContextFactory
#endif
#ifdef __MWERKS__
#pragma dont_inline on
#endif

void GUSISetupContextFactory()
{
}

#ifdef __MWERKS__
#pragma dont_inline reset
#endif
@

<<Implementation of completion handling>>=
static GUSIContextFactory *	sGUSIContextFactory;
static bool					sGUSIContextFactorySetup;

GUSIContextFactory * GUSIContextFactory::Instance()
{
	if (!sGUSIContextFactorySetup) {
		sGUSIContextFactorySetup = true;
		GUSISetupContextFactory();
	}

	if (!sGUSIContextFactory) 
		SetInstance(new GUSIContextFactory());
	
	return sGUSIContextFactory;
}

void GUSIContextFactory::SetInstance(GUSIContextFactory * instance)
{
	sGUSIContextFactory = instance;
}

void GUSIContextFactory::DeleteInstance()
{
	delete sGUSIContextFactory;
	sGUSIContextFactory = 0;
}

GUSIContextFactory::GUSIContextFactory()
{
}

GUSIContextFactory::~GUSIContextFactory()
{
}
@

<<Friends of [[GUSIContext]]>>=
friend class GUSIContextFactory;
<<Implementation of completion handling>>=
GUSIContext * GUSIContextFactory::CreateContext(
	ThreadEntryProcPtr threadEntry, void *threadParam, 
	Size stackSize, ThreadOptions options, void **threadResult, ThreadID *threadMade
) 
{
	GUSIContext::Setup(true);

	return new GUSIContext(threadEntry, threadParam, stackSize, options,
					threadResult, threadMade);
}

GUSIContext * GUSIContextFactory::CreateContext(ThreadID threadMade)
{
	GUSIContext::Setup(true);
	
	return new GUSIContext(threadMade);
}
@

The thread switcher dispatches to the appropriate member function.
<<Implementation of completion handling>>=
OSErr GUSISetThreadSwitcher(
	ThreadID thread, ThreadSwitchProcPtr threadSwitcher, void *switchProcParam, Boolean inOrOut)
{
	GUSIContext * context;
	if (!(context = GUSIContext::Lookup(thread)))
		return GUSIThreadManagerProxy::Instance()->SetThreadSwitcher(
			thread, threadSwitcher, switchProcParam, inOrOut);
	if (inOrOut) 
		context->SetSwitchIn(threadSwitcher, switchProcParam);
	else
		context->SetSwitchOut(threadSwitcher, switchProcParam);
	return noErr;
}

void GUSIContext::SetSwitchIn(ThreadSwitchProcPtr switcher, void *switchParam)
{
	fSwitchInProc = switcher;
	fSwitchInParam= switchParam;
}

void GUSIContext::SetSwitchOut(ThreadSwitchProcPtr switcher, void *switchParam)
{
	fSwitchOutProc = switcher;
	fSwitchOutParam= switchParam;
}
@

Similar for the thread terminator.
<<Implementation of completion handling>>=
OSErr GUSISetThreadTerminator(
	ThreadID thread, ThreadTerminationProcPtr threadTerminator, void *terminationProcParam)
{
	GUSIContext * context;
	if (!(context = GUSIContext::Lookup(thread)))
		return GUSIThreadManagerProxy::Instance()->SetThreadTerminator(
			thread, threadTerminator, terminationProcParam);
	context->SetTerminator(threadTerminator, terminationProcParam);
	
	return noErr;
}

void GUSIContext::SetTerminator(ThreadTerminationProcPtr terminator, void *terminationParam)	
{
	fTerminateProc = terminator;
	fTerminateParam= terminationParam;
}
@

The hooks, after having performed their task, call through to user defined hooks.
<<Implementation of completion handling>>=
#if GENERATING68K && GENERATINGCFM
#define CallThreadSwitchProc(userRoutine, thread, context)	\
	CallUniversalProc((userRoutine), uppThreadSwitchProcInfo, (thread), (context))
#define CallThreadTerminationProc(userRoutine, thread, context)	\
	CallUniversalProc((userRoutine), uppThreadTerminationProcInfo, (thread), (context))
#else
#define CallThreadSwitchProc(userRoutine, thread, context)	\
	(*userRoutine)((thread), (context))
#define CallThreadTerminationProc(userRoutine, thread, context)	\
	(*userRoutine)((thread), (context))
#endif
@

The thread switcher updates the pointer to the current context and switches
the global error variables.
<<Friends of [[GUSIContext]]>>=
friend pascal void GUSIThreadSwitchIn(ThreadID thread, GUSIContext * context);
friend pascal void GUSIThreadSwitchOut(ThreadID thread, GUSIContext * context);
<<Implementation of completion handling>>=
pascal void GUSIThreadSwitchIn(ThreadID, GUSIContext * context)
{
	context->SwitchIn();
}

void GUSIContext::SwitchIn()
{
	if (sCurrentContext != this) {
		GUSI_MESSAGE(("Yield #%d -> #%d\n", sCurrentContext->fThreadID, fThreadID));
		
		fEntryTicks = LMGetTicks();
	}
	sCurrentContext	= 	this;
	errno			=	fErrno;
	h_errno			=	fHostErrno;
	
	if (fFlags & asleep) {
		fFlags &= ~asleep;
		++fProcess->fReadyThreads;
		fProcess->fDontSleep = false; // We're back to at least 2 threads
	}
	
	if (fSwitchInProc)
		CallThreadSwitchProc(fSwitchInProc, fThreadID, fSwitchInParam);
}
@

When we are switched out, we check whether we should wake up again right away.
Pleasantly enough, there are no race conditions between this code and 
[[GUSIContext::Wakeup()]]:

\begin{Itemize}
\item By the time [[GUSIThreadSwitchOut]] is called, the thread state is 
	already set to stopped, so the [[GetThreadStateGivenTaskRef]] call in
	[[GUSIContext::Wakeup]] will take effect.
\item If [[GUSIContext::Wakeup]] is called before [[GUSIThreadSwitchOut]],
	it will be able to set [[fWakeup]] in time for the switchout procedure
	to notice and set the thread to ready again.
\end{itemize}

<<Implementation of completion handling>>=
pascal void GUSIThreadSwitchOut(ThreadID, GUSIContext * context)
{
	context->SwitchOut();
}

void GUSIContext::SwitchOut()
{
	if (fSwitchOutProc)
		CallThreadSwitchProc(fSwitchOutProc, fThreadID, fSwitchOutParam);
	fErrno		=	errno;
	fHostErrno	=	h_errno;
	
	ThreadTaskRef	taskRef = Process()->GetTaskRef();
	ThreadState		state;
	if (!GetThreadStateGivenTaskRef(taskRef, fThreadID, &state))
		if (state == kStoppedThreadState)
			if (fWakeup) {
				SetThreadReadyGivenTaskRef(taskRef, fThreadID);
			} else {
				GUSI_MESSAGE(("Sleep #%d\n", fThreadID));
				fFlags |= asleep;
				--fProcess->fReadyThreads;
			}
}
@

The terminator wakes up the joining thread if a join is pending. 
<<Friends of [[GUSIContext]]>>=
friend pascal void GUSIThreadTerminator(ThreadID thread, GUSIContext * context);
<<Implementation of completion handling>>=
pascal void GUSIThreadTerminator(ThreadID, GUSIContext * context)
{
	context->Terminate();
}

void GUSIContext::Terminate()
{
	--fProcess->fExistingThreads;
	if (!(fFlags & asleep))
		--fProcess->fReadyThreads;
	if (fTerminateProc)
		CallThreadTerminationProc(fTerminateProc, fThreadID, fTerminateParam);
	if (fFlags & detached) {
		delete this;
	} else {
		fFlags |= done;
		if (fJoin)
			fJoin->Wakeup();
	}
	GUSI_MESSAGE(("Terminate #%d\n", fThreadID));
}
@

[[Done]] is simple unless [[join]] is set. Otherwise, we set [[fJoin]] and 
wait. If some other process is already joining, we bail out.
<<Implementation of completion handling>>=
bool GUSIContext::Done(bool join)
{
	if ((fFlags & done) || !join || fJoin)
		return (fFlags & done);
	fJoin = GUSIContext::sCurrentContext;
	while (!(fFlags & done))
		Yield(kGUSIBlock);
	return (fFlags & done);
}
@

[[Yield]] tries to do the smart thing in all contexts. The basic idea is that 
both in threading and non-threading contexts, everyone gets their fair turn.
We'll start with some constants determining scheduling policy (which we possibly 
should make user configurable).
<<Implementation of completion handling>>=
const int kThreadTimeSliceTicks		=	12;
const int kProcessTimeSliceTicks	= 	20;
const int kProcessSleepTicks		= 	60;
<<Implementation of completion handling>>=
bool GUSIContext::Yield(GUSIYieldMode wait)
{
	<<Determine process and blocking parameters>>
	<<Check thread timeslice before doing voluntary switch>>
	
	bool 			interrupt 	= false;
	
	do {
		<<Suspend the current process if necessary>>
		<<Check for eligible signals>>
		<<Suspend the current thread if possible>>
	} while (wait == kGUSIBlock && !sCurrentContext->fWakeup);
done:
	sCurrentContext->fWakeup = false;
	
	return interrupt;
}
<<Check thread timeslice before doing voluntary switch>>=
if (wait == kGUSIYield && LMGetTicks() - sCurrentContext->fEntryTicks < kThreadTimeSliceTicks)
	return false;	
<<Determine process and blocking parameters>>=
bool			mainThread	= CreateCurrent()->fThreadID == kApplicationThreadID;
bool 			block		= wait == kGUSIBlock && !mainThread;
GUSIProcess	*	process 	= GUSIProcess::Instance();
<<Suspend the current process if necessary>>=
if (mainThread)
	process->Yield(wait);
<<Check for eligible signals>>=
if (interrupt = Interrupt())
	goto done;
<<Suspend the current thread if possible>>=
if (sHasThreading) {
	if (block)
		SetThreadState(kCurrentThreadID, kStoppedThreadState, kNoThreadID);
	else
		YieldToAnyThread();
}
@

[[SigWait]] and [[SigSuspend]] are similar to [[Yield]]. The former waits for
one of the specified signals to become pending, while the latter waits for
any signal to become executed.
<<Implementation of completion handling>>=
void GUSIContext::SigWait(sigset_t sigs)
{
	GUSIYieldMode 	wait		= kGUSIBlock;	
	<<Determine process and blocking parameters>>
	
	for (;;) {
		<<Suspend the current process if necessary>>
		if (Pending() & sigs)
			break;
		Interrupt();
		<<Suspend the current thread if possible>>
	}
	sCurrentContext->fWakeup = false;
}

void GUSIContext::SigSuspend()
{
	GUSIYieldMode 	wait		= kGUSIBlock;	
	<<Determine process and blocking parameters>>
	
	for (;;) {
		<<Suspend the current process if necessary>>
		if (Interrupt(true))
			break;
		<<Suspend the current thread if possible>>
	}
	sCurrentContext->fWakeup = false;
}
@

[[GUSIProcess::Yield]] tries to narrow down the critical time for race conditions,
so we rarely have to force a wakeup. This is done using the [[fWillSleep]] and [[fDontSleep]]
flags. The former signals the processes willingness to block, the latter is set by wakeup
routines to try stopping it from doing so. According to Andreas Grosam, the thread manager 
may need a number of calls to [[YieldToAnyThread]] to reorganize its queues, so we leave the
[[fDontSleep]] flag set until the number of ready threads increases above 2 or the number of
threads in the process drops to 1 -- the application thread itself.
<<Implementation of completion handling>>=
void GUSIProcess::Yield(GUSIYieldMode wait)
{
	<<Check for interrupts if we are the front process>>
	if (wait == kGUSIBlock) {
		fWillSleep = true;
		if (fReadyThreads > 1 || fDontSleep) {
			GUSI_SMESSAGE("Don't Sleep\n");
			wait = kGUSIYield;
		}
	}
	if (fExistingThreads < 2) // Single threaded process skips sleep only once
		fDontSleep = false;
	if (wait == kGUSIYield && LMGetTicks() - fResumeTicks < kProcessTimeSliceTicks) {
		fWillSleep 		= false;
		return;
	}
	if (gGUSISpinHook) {
		gGUSISpinHook(wait == kGUSIBlock);
	} else {
		GUSI_SMESSAGE("Suspend\n");
		GUSIHandleNextEvent(wait == kGUSIBlock ? kProcessSleepTicks : 0);
		GUSI_SMESSAGE("Resume\n");
	} 
	if (fExistingThreads < 2) 		// Single threaded process skips sleep only once
		fDontSleep = false;
	fWillSleep 		= false;
	fResumeTicks 	= LMGetTicks();
	if (fClosing)
		fClosing->CheckClose();
}
@

By definition, an interrupt key press is only intended for us if we are in front.
Applications can check this condition relatively easily by keeping track of
suspend and resume events, but as a library, the only reliable way is to compare
PSNs.
<<Check for interrupts if we are the front process>>=
ProcessSerialNumber	front;
Boolean				same;
	
if (!GetFrontProcess(&front) && !SameProcess(&front, &fProcess, &same) && same)
	GUSIConfiguration::Instance()->CheckInterrupt();
@

[[Raise]] raises all eligible signals. [[Interrupt]] checks for interrupting signals.
[[Pending]] returns the pending signals. [[Blocked]] returns the blocked signals.
<<Implementation of completion handling>>=
void GUSIContext::Raise()
{
	sCurrentContext->SigContext()->Raise(
		GUSIProcess::Instance()->SigProcess());
}

bool GUSIContext::Interrupt(bool allSigs)
{
	return sCurrentContext->SigContext()->Interrupt(
		GUSIProcess::Instance()->SigProcess(), allSigs);
}

sigset_t GUSIContext::Pending()
{
	return sCurrentContext->SigContext()->Pending(
		GUSIProcess::Instance()->SigProcess());
}

sigset_t GUSIContext::Blocked()
{
	return sCurrentContext->SigContext()->GetBlocked();
}
@

Many different asynchronous calls can be handled by [[GUSIIODone]].
<<Implementation of completion handling>>=
inline GUSIContext *& Context(ParamBlockRec * pb)
{
	return reinterpret_cast<GUSIContext **>(pb)[-1];
}
static pascal void GUSIIODone(ParamBlockRec * pb)
{
	if (Context(pb)) 
		Context(pb)->Wakeup();
}

GUSI_COMPLETION_PROC_A0(GUSIIODone, ParamBlockRec)
@

Since we (or at least I) never quite know when a call is executed synchronously,
we set the context field to [[nil]] until after the call. This avoids having to 
wake up a running context, which is a fairly costly operation.
<<Implementation of completion handling>>=
void GUSIStartIO(ParamBlockRec * pb)
{
	static IOCompletionUPP sIODone = 0;
	
	if (!sIODone)
		sIODone = NewIOCompletionProc(GUSIIODoneEntry);
	Context(pb) 		= nil;
	pb->ioParam.ioCompletion 	= sIODone;
}

OSErr GUSIFinishIO(ParamBlockRec * pb)
{
	Context(pb) 		= GUSIContext::CreateCurrent();
	while (pb->ioParam.ioResult > 0)
		GUSIContext::Yield(kGUSIBlock);
	return pb->ioParam.ioResult;
}

OSErr GUSIControl(ParamBlockRec * pb)
{
	GUSIStartIO(pb);
	PBControlAsync(reinterpret_cast<ParmBlkPtr>(pb));
	return GUSIFinishIO(pb);
}
@

The default implementation of [[GUSIThreadManagerProxy]] is trivial.
<<Implementation of completion handling>>=
static auto_ptr<GUSIThreadManagerProxy> sGUSIThreadManagerProxy;

OSErr GUSIThreadManagerProxy::NewThread(
		ThreadStyle threadStyle, ThreadEntryProcPtr threadEntry, void *threadParam, 
		Size stackSize, ThreadOptions options, 
		void **threadResult, ThreadID *threadMade)
{
	return ::NewThread(
				threadStyle, threadEntry, threadParam, stackSize, options, 
				threadResult, threadMade);
}

OSErr GUSIThreadManagerProxy::SetThreadSwitcher(ThreadID thread, 
		ThreadSwitchProcPtr threadSwitcher, void *switchProcParam, Boolean inOrOut)
{
	return ::SetThreadSwitcher(thread, threadSwitcher, switchProcParam, inOrOut);
}

OSErr GUSIThreadManagerProxy::SetThreadTerminator(ThreadID thread, 
		ThreadTerminationProcPtr threadTerminator, void *terminationProcParam)
{
	return ::SetThreadTerminator(thread, threadTerminator, terminationProcParam);
}

GUSIThreadManagerProxy * GUSIThreadManagerProxy::Instance()
{ 
	if (!sGUSIThreadManagerProxy.get()) 
		sGUSIThreadManagerProxy = auto_ptr<GUSIThreadManagerProxy>(MakeInstance()); 
	return sGUSIThreadManagerProxy.get(); 
}

GUSIThreadManagerProxy * GUSIThreadManagerProxy::MakeInstance()
{
	return new GUSIThreadManagerProxy;
}
@
