%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Project	:	GUSI				-	Grand Unified Socket Interface
% File		:	GUSITimer.nw		-	Timing functions
% Author	:	Matthias Neeracher
% Language	:	C++
% 
% $Log: GUSITimer.nw,v $
% Revision 1.13  2002/01/07 05:56:20  neeri
% Compatibility fixes for CodeWarrior Pro 7
%
% Revision 1.12  2001/01/17 08:48:04  neeri
% Introduce Expired(), Reset()
%
% Revision 1.11  2000/10/29 18:36:32  neeri
% Fix time_t signedness issues
%
% Revision 1.10  2000/06/12 04:24:50  neeri
% Fix time, localtime, gmtime
%
% Revision 1.9  2000/05/23 07:24:58  neeri
% Improve formatting
%
% Revision 1.8  2000/03/15 07:22:07  neeri
% Enforce alignment choices
%
% Revision 1.7  1999/11/15 07:20:18  neeri
% Safe context setup
%
% Revision 1.6  1999/08/26 05:45:10  neeri
% Fixes for literate edition of source code
%
% Revision 1.5  1999/08/02 07:02:46  neeri
% Support for asynchronous errors and other socket options
%
% Revision 1.4  1999/07/07 04:17:43  neeri
% Final tweaks for 2.0b3
%
% Revision 1.3  1999/06/28 06:08:46  neeri
% Support flexible timer classes
%
% Revision 1.2  1999/05/30 03:06:21  neeri
% Fixed various bugs in cleanup and wakeup
%
% Revision 1.1  1999/03/17 09:05:14  neeri
% Added GUSITimer, expanded docs
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Timing functions}

This section defines mechanisms to measure time. The basic mechanism is
[[GUSITimer]] which can wake up a [[GUSIContext]] at some later time.
<<GUSITimer.h>>=
#ifndef _GUSITimer_
#define _GUSITimer_

#ifndef GUSI_SOURCE

typedef struct GUSITimer GUSITimer;

#else
#include "GUSISpecific.h"

#include <errno.h>
#include <sys/cdefs.h>
#include <sys/types.h>
#include <sys/time.h>
#include <inttypes.h>

#include <MacTypes.h>
#include <Timer.h>
#include <Math64.h>

#include <ConditionalMacros.h>

#if PRAGMA_STRUCT_ALIGN
#pragma options align=native
#endif

<<Definition of class [[GUSITime]]>>
<<Definition of class [[GUSITimer]]>>

#if PRAGMA_STRUCT_ALIGN
#pragma options align=reset
#endif

#endif /* GUSI_SOURCE */

#endif /* _GUSITimer_ */
@

<<GUSITimer.cp>>=
#include "GUSIInternal.h"
#include "GUSITimer.h"
#include "GUSIDiag.h"
#include "GUSIContext.h"

#include <errno.h>

<<Member functions for class [[GUSITime]]>>
<<Member functions for class [[GUSITimer]]>>
@


\section{Definition of timing}

[[GUSITime]] is an universal (if somewhat costly) format for 
the large variety of timing formats used in MacOS and POSIX.
<<Definition of class [[GUSITime]]>>=
class GUSITime {
public:
	enum Format {seconds, ticks, msecs, usecs, nsecs};
	
#if !TYPE_LONGLONG
	GUSITime(int32_t  val, Format format);
	GUSITime(uint32_t val, Format format);
#endif
	GUSITime(int64_t val, Format format=nsecs) 	{ Construct(val, format); }
	GUSITime(const timeval & tv);
	GUSITime(const timespec & ts);
	GUSITime(const tm & t);
	GUSITime() {}
	
	int32_t		Get(Format format)		{ return S32Set(Get64(format)); 		}
	uint32_t	UGet(Format format)		
							{ return U32SetU(SInt64ToUInt64(Get64(format)));	}
	int64_t		Get64(Format format);
	
	operator int64_t()		{	return fTime;	}
	operator timeval();
	operator timespec();
	operator tm();
	
	GUSITime GM2LocalTime();
	GUSITime Local2GMTime();
	
	GUSITime & operator +=(const GUSITime & other) 
		{ fTime = S64Add(fTime, other.fTime); return *this; }
	GUSITime & operator -=(const GUSITime & other) 
		{ fTime = S64Subtract(fTime, other.fTime); return *this; }
	
	
	static GUSITime 	Now();
	static timezone	&	Zone();
private:
	void	Construct(int64_t val, Format format);
	time_t	Deconstruct(int64_t & remainder);
	
	int64_t	fTime;
	
	static	int64_t		sTimeOffset;
	static	timezone	sTimeZone;
};

inline GUSITime operator+(const GUSITime & a, const GUSITime & b)
					{ GUSITime t(a); return t+=b; }
inline GUSITime operator-(const GUSITime & a, const GUSITime & b)
					{ GUSITime t(a); return t-=b; }
@ %def GUSITime

A [[GUSITimer]] is a time manager task that wakes up a [[GUSIContext]].
<<Definition of class [[GUSITimer]]>>=
#if PRAGMA_STRUCT_ALIGN
#pragma options align=mac68k
#endif
class GUSIContext;

extern "C" void GUSIKillTimers(void * timers);

class GUSITimer : public TMTask {
public:
	GUSITimer(bool wakeup = true, GUSIContext * context = 0);
	virtual ~GUSITimer();
	
	void			Sleep(long ms, bool driftFree = false);
	void			MicroSleep(long us, bool driftFree = false)
										{ Sleep(-us, driftFree);				}
	GUSIContext *	Context()			{ return fQueue->fContext;				}
	GUSITimer *		Next()				{ return fNext;							}
	bool			Primed()			{ return (qType&kTMTaskActive) != 0; 	}
	bool			Expired()			{ return !(qType&kTMTaskActive); 		}
	virtual void	Wakeup();
	void			Kill();
	void			Reset();
	
	struct Queue {
		GUSITimer 	*	fTimer;
		GUSIContext *	fContext;
		
		Queue() : fTimer(0) {}
	};
	
	QElem *	Elem()		{	return reinterpret_cast<QElem *>(&this->qLink); }
protected:
	Queue *			fQueue;
	GUSITimer * 	fNext;
	
	class TimerQueue : public GUSISpecificData<Queue,GUSIKillTimers> {
	public:
		~TimerQueue();
	};
	
	static TimerQueue	sTimerQueue;
	static TimerUPP		sTimerProc;
};
#if PRAGMA_STRUCT_ALIGN
#pragma options align=reset
#endif
@

\section{Implementation of [[GUSITime]]}

The constructors need various multiplicators.
<<Member functions for class [[GUSITime]]>>=
#if !TYPE_LONGLONG
GUSITime::GUSITime(int32_t val, Format format)
{
	Construct(S64Set(val), format);
}

GUSITime::GUSITime(uint32_t val, Format format)
{
	Construct(S64SetU(val), format);
}
#endif

void GUSITime::Construct(int64_t val, Format format)
{
	switch (format) {
	case seconds:
		fTime = S64Multiply(val, S64Set(1000000000));
		break;
	case ticks:
		fTime = S64Multiply(val, S64Set(16666667));
		break;
	case msecs:
		fTime = S64Multiply(val, S64Set(1000000));
		break;
	case usecs:
		fTime = S64Multiply(val, S64Set(1000));
		break;
	case nsecs:
		fTime = val;
		break;
	}
}
@

The struct constructors are simple arithmetic.
<<Member functions for class [[GUSITime]]>>=
GUSITime::GUSITime(const timeval & tv)
{
	*this = GUSITime(tv.tv_sec, seconds) + GUSITime(tv.tv_usec, usecs);
}

GUSITime::GUSITime(const timespec & ts)
{
	*this = GUSITime(ts.tv_sec, seconds) + GUSITime(ts.tv_nsec, nsecs);
}
@

The basic get operation is the one returning an [[int64_t]].
<<Member functions for class [[GUSITime]]>>=
int64_t GUSITime::Get64(Format format)
{
	switch (format) {
	case seconds:
		return S64Div(fTime, S64Set(1000000000));
	case ticks:
		return S64Div(fTime, S64Set(16666667));
	case msecs:
		return S64Div(fTime, S64Set(1000000));
	case usecs:
		return S64Div(fTime, S64Set(1000));
	default:
	case nsecs:
		return fTime;
	}
}
@

The struct casts break down the value into seconds and a remainder. For some
reason, S64Divide is not defined for native functions.
<<Member functions for class [[GUSITime]]>>=
time_t GUSITime::Deconstruct(int64_t & rem)
{
#if TYPE_LONGLONG
	rem = S64Mod(fTime, S64Set(1000000000));
	return static_cast<time_t>(U32SetU(SInt64ToUInt64(S64Div(fTime, S64Set(1000000000)))));
#else
	return static_cast<time_t>(U32SetU(SInt64ToUInt64(S64Divide(fTime, S64Set(1000000000), &rem))));
#endif
}

GUSITime::operator timeval()
{
	timeval	tv;
	int64_t	rem;
	
	tv.tv_sec	= Deconstruct(rem);
	tv.tv_usec	= S32Set(S64Div(rem, S64Set(1000)));
	
	return tv;
}

GUSITime::operator timespec()
{
	timespec	ts;
	int64_t		rem;
	
	ts.tv_sec	= Deconstruct(rem);
	ts.tv_nsec	= S32Set(rem);
	
	return ts;
}
@

We construct a [[struct tm]] via [[LongSecondsToDate]].
<<Member functions for class [[GUSITime]]>>=
GUSITime::operator tm()
{
	tm				t;
	LongDateRec		ldr;
	LongDateTime	ldt;
	
	ldt = Get64(seconds);
	LongSecondsToDate(&ldt, &ldr);
	t.tm_sec	=	ldr.ld.second;
	t.tm_min	=	ldr.ld.minute;
	t.tm_hour	=	ldr.ld.hour;
	t.tm_mday	=	ldr.ld.day;
	t.tm_mon	=	ldr.ld.month-1;
	t.tm_year	=	ldr.ld.year-1900;	
	t.tm_wday	=	ldr.ld.dayOfWeek-1;
	t.tm_yday	=	ldr.ld.dayOfYear-1;
	t.tm_isdst	=	-1;
	
	return t;
}
@

Constructing a [[GUSITime]] from a [[struct tm]] is a bit trickier because
field values are not guaranteed to be in range and [[LongDateToSeconds]] is
not infinitely tolerant.
<<Member functions for class [[GUSITime]]>>=
GUSITime::GUSITime(const tm & t)
{
	LongDateRec		ldr;
	LongDateTime	ldt;
	
	ldr.ld.era 		= 	0;
	ldr.ld.year		=	t.tm_year+1900;
	ldr.ld.month	=	t.tm_mon+1;
	ldr.ld.day		=	t.tm_mday ? t.tm_mday : 1;
	ldr.ld.hour		=	t.tm_hour>=0 ? t.tm_hour : 0;
	ldr.ld.minute	=	t.tm_min>=0 ? t.tm_min : 0;
	ldr.ld.second	=	t.tm_sec>=0 ? t.tm_sec : 0;
	
	LongDateToSeconds(&ldr, &ldt);
	if (!t.tm_mday)
		ldt = S64Subtract(ldt, S64Set(86400));
	if (t.tm_hour < 0)
		ldt = S64Add(ldt, S64Multiply(S64Set(t.tm_hour), S64Set(3600)));
	if (t.tm_min < 0)
		ldt = S64Add(ldt, S64Multiply(S64Set(t.tm_min), S64Set(60)));
	if (t.tm_sec < 0)
		ldt = S64Add(ldt, S64Set(t.tm_sec));
		
	Construct(ldt, seconds);
}
@

To calculate the current time, we need to combine [[GetDateTime]], which gives
seconds since 1904, with [[Microseconds]], which gives microseconds since startup.
<<Member functions for class [[GUSITime]]>>=
int64_t		GUSITime::sTimeOffset;
timezone 	GUSITime::sTimeZone;

GUSITime GUSITime::Now()
{
	if (S64Not(sTimeOffset)) {
		GUSITime	s;
		GUSITime	zone;
		GUSITime	us;
		
		{
			uint32_t	secs;
			GetDateTime(&secs);
			s = GUSITime(secs, seconds);
		}
		{
			UnsignedWide	u;
			Microseconds(&u);
			us = GUSITime(UInt64ToSInt64(UnsignedWideToUInt64(u)), usecs);
		}
		{
			MachineLocation loc;
			ReadLocation(&loc);
			int32_t delta = loc.u.gmtDelta & 0x00FFFFFF;
			if (delta & 0x00800000)
				delta |= 0xFF000000;
			zone = GUSITime(delta, seconds);
			sTimeZone.tz_minuteswest = zone.Get(seconds) / 60;
			sTimeZone.tz_dsttime	 = (loc.u.gmtDelta & 0xFF000000) != 0;
		}
		s -= zone;
		sTimeOffset =  s - us;
		
		return s;
	} else {
		UnsignedWide	us;
		Microseconds(&us);
		GUSITime	t(UInt64ToSInt64(UnsignedWideToUInt64(us)), usecs);
		
		return S64Add(int64_t(t), sTimeOffset);
	}
}
@

The time zone is cached by [[Now]].
<<Member functions for class [[GUSITime]]>>=
timezone & GUSITime::Zone()
{
	Now();
	return sTimeZone;
}

GUSITime GUSITime::Local2GMTime()
{
	Now();
	
	GUSITime zone(static_cast<int32_t>(60*sTimeZone.tz_minuteswest), seconds);
	
	return *this - zone;
}

GUSITime GUSITime::GM2LocalTime()
{
	Now();
	
	GUSITime zone(static_cast<int32_t>(60*sTimeZone.tz_minuteswest), seconds);
	
	return *this+zone;
}
@

\section{Implementation of [[GUSITimer]]}

[[GUSITimerProc]] wakes up the context.
<<Member functions for class [[GUSITimer]]>>=
static pascal void GUSITimerProc(TMTask * tm)
{
	GUSITimer * timer = static_cast<GUSITimer *>(tm);
	
	GUSIProcess::A5Saver	saveA5(timer->Context());
	
	timer->Wakeup();
}

GUSI_COMPLETION_PROC_A1(GUSITimerProc, TMTask)
@ %def GUSITimerProc

The default wakeup action simply wakes up the associated context.
<<Member functions for class [[GUSITimer]]>>=
void GUSITimer::Wakeup()
{ 
	Context()->Wakeup();					
}
@

When a process terminates, all remaining timers get destroyed.
<<Member functions for class [[GUSITimer]]>>=
GUSITimer::TimerQueue::~TimerQueue()
{
	GUSIContext::LiquidateAll();
}

void GUSIKillTimers(void * timers)
{
	GUSITimer::Queue * q = static_cast<GUSITimer::Queue *>(timers);
	
	while (q->fTimer)
		q->fTimer->Kill();
		
	delete q;
}
@ %def GUSIKillTimers

On constructing the first [[GUSITimer]] in a program, we initialize [[sTimerProc]].
<<Member functions for class [[GUSITimer]]>>=
TimerUPP 				GUSITimer::sTimerProc = (TimerUPP)0;
GUSITimer::TimerQueue	GUSITimer::sTimerQueue;

GUSITimer::GUSITimer(bool wakeup, GUSIContext * context)
{
	if (!context)
		context 	= GUSIContext::CreateCurrent();
	if (wakeup) {
		if (!sTimerProc)
			sTimerProc 	= NewTimerProc(GUSITimerProcEntry);
		tmAddr 			= sTimerProc;
	} else
		tmAddr  		= 0;
	tmCount				= 0;
	tmWakeUp			= 0;
	tmReserved			= 0;
	InsXTime(Elem());
	fQueue 				= sTimerQueue.get(context);
	fQueue->fContext	= context;
	fNext 				= fQueue->fTimer;
	fQueue->fTimer 		= this;
}
@

We support both normal timing and drift free timers.
<<Member functions for class [[GUSITimer]]>>=
void GUSITimer::Sleep(long ms, bool driftFree)
{
	if (!driftFree)
		tmWakeUp = 0;
	PrimeTime(Elem(), ms);
}
@

To reset the timer, we remove it and insert it again.
<<Member functions for class [[GUSITimer]]>>=
void GUSITimer::Reset()
{
	RmvTime(Elem());
	InsXTime(Elem());
}
@

Upon destruction, we remove the time manager task. The [[fQueue]] element serves as a
flag so we don't get killed twice.
<<Member functions for class [[GUSITimer]]>>=
void GUSITimer::Kill()
{
	if (!fQueue)	// We are dead already
		return;

	RmvTime(Elem());
	GUSITimer ** queue = &fQueue->fTimer;
	
	while (*queue)
		if (*queue == this) {
			*queue = fNext; 
			
			break;
		} else
			queue = &(*queue)->fNext;
	fNext 	= 0;
	fQueue	= 0;
}

GUSITimer::~GUSITimer()
{
	Kill();
}
@

