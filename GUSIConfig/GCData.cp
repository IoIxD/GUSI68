/*
	File:			GCData.h

	Contains:	Configuration data.

	$Log: GCData.cp,v $
	Revision 1.3  1999/06/30 07:42:01  neeri
	Getting ready to release 2.0b3
	
	Revision 1.2  1999/06/24 06:39:33  neeri
	Added SIGINT flag
	
	Revision 1.1  1999/04/10 03:52:46  neeri
	Initial Version
	
*/

#include "GCData.h"

#include <time.h>
#include <string.h>

#include <Memory.h>
#include <Processes.h>

GCOptionTable	gGCSockets;
GCOptionTable	gGCDevices;
GCFlagTable		gGCFlags;
GCFileTable		gGCFiles;
OSType			gGCType;
OSType			gGCCreator;
Boolean			gGCHasConfig;

void DefaultFlags(bool hasConfigSection)
{
	GCFlag	yes(true, true);
	GCFlag	no(false, false);
	
	gGCFlags["AutoSpin"] 			= yes;
	gGCFlags["AccurateStat"]		= no;
	gGCFlags["AutoInitGraf"] 		= yes;
	gGCFlags["SharedOpen"]			= no;
	gGCFlags["HandleAppleEvents"]	= yes;
	gGCFlags["SigPipe"]				= no;
	gGCFlags["SigInt"]				= yes;
	
	gGCType		= 'TEXT';
	gGCCreator	= 'MPS ';
	
	gGCHasConfig= !hasConfigSection;
}

void DefaultSockets(bool hasConfigSection)
{
	gGCSockets["Inet"]		= !hasConfigSection;
	gGCSockets["MTInet"]		= false;
	gGCSockets["MTTcp"]		= false;
	gGCSockets["MTUdp"]		= false;
	gGCSockets["OTInet"]		= false;
	gGCSockets["OTTcp"]		= false;
	gGCSockets["OTUdp"]		= false;
	gGCSockets["PPC"]			= false;
	gGCSockets["Local"]		= false;
}

void DefaultDevices(bool hasConfigSection)
{
	gGCDevices["Null"]		= !hasConfigSection;
	gGCDevices["DCon"]		= false;
}

void Panic(Handle header, Handle footer)
{
	DisposeHandle(header);
	DisposeHandle(footer);
	
	ExitToShell();
}

Boolean ReadData(std::istream & is, Handle header, Handle footer)
{
	char 	line[1024];
	char *s;
	char *s2;
	
	for (;;) {
		if (!is.getline(line, 1024))
			return false;
		if (strstr(line, "BEGIN GUSI CONFIGURATION"))
			break;
		if (PtrAndHand(line, header, strlen(line)))
			Panic(header, footer);
	}
	DefaultFlags(true);
	DefaultSockets(true);
	DefaultDevices(true);

	Boolean	inProcedure = false;
	Boolean	inComment   = false;
	Boolean	inSuffices  = false;
	for (;;is.getline(line, 1024)) {
		if (!is)
			return true;
		if (strstr(line, "END GUSI CONFIGURATION"))
			break;
		if (line[0] == '{')
			inProcedure = true;
		if (line[0] == '}')
			inProcedure = inSuffices = false;
		if (s = strstr(line, "//"))
			*s = 0;
retryComment:
		if (s = strstr(line, "/*"))
			if (s2 = strstr(s+2, "*/")) {
				strcpy(s, s2+2);
				
				goto retryComment;
			} else {
				*s = 0;
				inComment = true;
			}
		if (s = strstr(line, "*/")) {
			strcpy(line, s+2);
			inComment = false;
		}
		if (strstr(line, "sSuffices[]")) {
			gGCHasConfig = inSuffices = true;
			continue;
		}
		if (inSuffices) {
			GCTypeCreator tc;
			if ((s = strchr(line, '\'')) && s[5]=='\'') {
				memcpy(&tc.fType, s+1, 4);
				if ((s = strchr(s+6, '\'')) && s[5]=='\'') {
					memcpy(&tc.fCreator, s+1, 4);
					if ((s = strchr(line, '"')) && (s2 = strchr(++s, '"')) && s2 != s) {
						*s2 = 0;
						gGCFiles[s] = tc;
					}
				}
			}
			continue;
		}
		if (inComment || !inProcedure)
			continue;
		if (s = strstr(line, "GUSIwith")) {
			s += 8;
			if (s2 = strstr(s, "Sockets")) {
				*s2 = 0;
				if (gGCSockets.find(s) != gGCSockets.end())
					gGCSockets[s] = true;
				else if (gGCDevices.find(s) != gGCDevices.end())
					gGCDevices[s] = true;
			} 
			continue;
		}
		if (s = strstr(line, "ConfigureDefaultTypeCreator")) {
			if ((s = strchr(s, '\'')) && s[5] == '\'') {
				memcpy(&gGCType, s+1, 4);
				if ((s = strchr(s+6, '\'')) && s[5] == '\'')
					memcpy(&gGCCreator, s+1, 4);
			}
			continue;
		}
		if (s = strstr(line, "ConfigureSuffices"))
			continue;
		if (s = strstr(line, "Configure")) {
			for (s = s2 = s+9; *++s2 && isalpha(*s2); )
				;
			if (*s2) {
				*s2 = 0;
				if (gGCFlags.find(s) != gGCFlags.end() && (s2 = strpbrk(s2+1, "tf")))
					gGCFlags[s].first = *s2=='t';
			}
			continue;
		}
	}
	while (is.getline(line, 1024))
		if (PtrAndHand(line, footer, strlen(line)))
			Panic(header, footer);
	
	return true;
}

static char * ostype(OSType t)
{
	static char s[7] = "'    '";
	
	memcpy(s+1, &t, 4);
	
	return s;
}

void WriteData(std::ostream & s, Handle header, Handle footer)
{
	time_t	t;
	long		sz;
	
	if (sz = GetHandleSize(header)) {
		HLock(header);
		s.write(*header, sz);
		HUnlock(header);
	}
	
	t = time(NULL);
	
	s 	<< "/**************** BEGIN GUSI CONFIGURATION ****************************\n"
		<< " *\n"
		<< " * GUSI Configuration section generated by GUSI Configurator\n"
		<< " * last modified: " << ctime(&t)
		<< " *\n"
		<< " * This section will be overwritten by the next run of Configurator.\n"
		<< " */\n"
		<< "\n"
		<< "#define GUSI_SOURCE\n"
		<< "#include <GUSIConfig.h>\n"
		<< "#include <sys/cdefs.h>\n"
		<< "\n"
		<< "/* Declarations of Socket Factories */\n"
		<< "\n"
		<< "__BEGIN_DECLS\n";
	
	for (GCOptionIterator i = gGCSockets.begin(); i != gGCSockets.end(); ++i)
		s << "void GUSIwith" << (*i).first << "Sockets();\n";
	
	s  << "void GUSISetupFactories();\n"
		<< "__END_DECLS\n"
		<< "\n"
		<< "/* Configure Socket Factories */\n"
		<< "\n"
		<< "void GUSISetupFactories()\n"
		<< "{\n"
		<< "#ifdef GUSISetupFactories_BeginHook\n"
		<< "	GUSISetupFactories_BeginHook\n"
		<< "#endif\n";
	
	for (GCOptionIterator i = gGCSockets.begin(); i != gGCSockets.end(); ++i)
		if ((*i).second)
			s << "\tGUSIwith" << (*i).first << "Sockets();\n";

	s 	<< "#ifdef GUSISetupFactories_EndHook\n"
		<< "	GUSISetupFactories_EndHook\n"
		<< "#endif\n"
		<< "}\n"
		<< "\n"
		<< "/* Declarations of File Devices */\n"
		<< "\n"
		<< "__BEGIN_DECLS\n";

	for (GCOptionIterator i = gGCDevices.begin(); i != gGCDevices.end(); ++i)
		s << "void GUSIwith" << (*i).first << "Sockets();\n";

	s 	<< "void GUSISetupDevices();\n"
		<< "__END_DECLS\n"
		<< "\n"
		<< "/* Configure File Devices */\n"
		<< "\n"
		<< "void GUSISetupDevices()\n"
		<< "{\n"
		<< "#ifdef GUSISetupDevices_BeginHook\n"
		<< "	GUSISetupDevices_BeginHook\n"
		<< "#endif\n";

	for (GCOptionIterator i = gGCDevices.begin(); i != gGCDevices.end(); ++i)
		if ((*i).second)
			s << "\tGUSIwith" << (*i).first << "Sockets();\n";

	s 	<< "#ifdef GUSISetupDevices_EndHook\n"
		<< "	GUSISetupDevices_EndHook\n"
		<< "#endif\n"
		<< "}\n"
		<< "\n";
	
	if (gGCHasConfig) {
		s	<< "#ifndef __cplusplus\n"
			<< "#error GUSISetupConfig() needs to be written in C++\n"
			<< "#endif\n"
			<< "\n"
			<< "GUSIConfiguration::FileSuffix	sSuffices[] = {\n";
		for (GCFileIterator i = gGCFiles.begin(); i != gGCFiles.end(); ++i)
			s 	<< "	\"" << (*i).first << "\", " << ostype((*i).second.fType)
				<<	", " << ostype((*i).second.fCreator) << ",\n";
		s	<< "	\"\", '????', '????'\n};\n"
			<< "\n"
			<< "extern \"C\" void GUSISetupConfig()\n"
			<< "{\n"
			<< "	GUSIConfiguration * config =\n"
			<< "		GUSIConfiguration::CreateInstance(GUSIConfiguration::kNoResource);\n"
			<< "\n";
		if (gGCType != 'TEXT' || gGCCreator != 'MPS ')
			s 	<< "	config->ConfigureDefaultTypeCreator(" << ostype(gGCType) 
				<< ", " << ostype(gGCCreator) << ");\n";
		s	<<	"	config->ConfigureSuffices(\n"
			<<	"		sizeof(sSuffices)/sizeof(GUSIConfiguration::FileSuffix)-1, sSuffices);\n";
		for (GCFlagIterator i = gGCFlags.begin(); i != gGCFlags.end(); ++i) 
			if ((*i).second.first != (*i).second.second)
				s	<<	"	config->Configure" << (*i).first 
					<< ((*i).second.first ? "(true);\n" : "(false);\n");
		s << "}\n\n";
	}
	
	s	<< "/**************** END GUSI CONFIGURATION *************************/\n"
		<< flush;

	if (sz = GetHandleSize(footer)) {
		HLock(footer);
		s.write(*footer, sz);
		HUnlock(footer);
	}
}
